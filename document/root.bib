
@inproceedings{Abdulaziz2022,
	title = {Formal {Semantics} and {Formally} {Verified} {Validation} for {Temporal} {Planning}},
	volume = {36},
	isbn = {1-57735-876-7},
	doi = {10.1609/aaai.v36i9.21197},
	abstract = {We present a simple and concise semantics for temporal planning. Our semantics are developed and formalised in the logic of the interactive theorem prover Isabelle/HOL. We derive from those semantics a validation algorithm for temporal planning and show, using a formal proof in Isabelle/HOL, that this validation algorithm implements our semantics. We experimentally evaluate our verified validation algorithm and show that it is practical.},
	booktitle = {Proceedings of the 36th {AAAI} {Conference} on {Artificial} {Intelligence}, {AAAI} 2022},
	author = {Abdulaziz, Mohammad and Koller, Lukas},
	year = {2022},
	note = {ISSN: 2159-5399},
	pages = {9635--9643},
}

@article{eriksson_unsolvability_2017,
	title = {Unsolvability {Certificates} for {Classical} {Planning}},
	author = {Eriksson, Salomé and Röger, Gabriele and Helmert, Malte},
	year = {2017},
}

@article{PDDL21,
	title = {{PDDL2}.1: {An} extension to {PDDL} for expressing temporal planning domains},
	journal = {Journal of artificial intelligence research},
	author = {Fox, Maria and Long, Derek},
	year = {2003},
}

@inproceedings{Lochbihler2013,
	title = {Light-weight containers for {Isabelle}: efficient, extensible, nestable},
	booktitle = {International {Conference} on {Interactive} {Theorem} {Proving}},
	publisher = {Springer},
	author = {Lochbihler, Andreas},
	year = {2013},
	pages = {116--132},
}

@book{bertot2004interactive,
	title = {Interactive theorem proving and program development: {Coq}'{Art}: the calculus of inductive constructions},
	publisher = {springer},
	author = {Bertot, Yves and Castéran, Pierre},
	year = {2004},
}

@book{Paulson1994Isabelle,
	title = {Isabelle: {A} generic theorem prover},
	volume = {828},
	publisher = {Springer},
	author = {Paulson, Lawrence C},
	year = {1994},
}

@inproceedings{Cashmore2015,
	title = {Rosplan: {Planning} in the robot operating system},
	volume = {2015-Janua},
	isbn = {978-1-57735-731-5},
	doi = {10.1609/icaps.v25i1.13699},
	abstract = {The Robot Operating System (ROS) is a set of software libraries and tools used to build robotic systems. ROS is known for a distributed and modular design. Given a model of the environment, task planning is concerned with the assembly of actions into a structure that is predicted to achieve goals. This can be done in a way that minimises costs, such as time or energy. Task planning is vital in directing the actions of a robotic agent in domains where a causal chain could lock the agent into a dead-end state. Moreover, planning can be used in less constrained domains to provide more intelligent behaviour. This paper describes the ROSPlan framework, an architecture for embedding task planning into ROS systems. We provide a description of the architecture and a case study in autonomous robotics. Our case study involves autonomous underwater vehicles in scenarios that demonstrate the flexibility and robustness of our approach.},
	booktitle = {Proceedings {International} {Conference} on {Automated} {Planning} and {Scheduling}, {ICAPS}},
	author = {Cashmore, Michael and Fox, Maria and Long, Derek and Magazzeni, Daniele and Ridder, Bram and Carrera, Arnau and Palomeras, Narcís and Hurtós, Natàlia and Carreras, Marc},
	year = {2015},
	note = {ISSN: 23340843},
	pages = {333--341},
}

@article{wirth_program_1971,
	title = {Program {Development} by {Stepwise} {Refinement}},
	volume = {14},
	issn = {15577317},
	doi = {10.1145/362575.362577},
	abstract = {The creative activity of programming--to be distinguished from coding--is usually taught by examples serving to exhibit certain techniques. It is here considered as a sequence of design decisions concerning the decomposition of tasks into subtasks and of data into data structures. The process of successive refinement of specifications is illustrated by a short but nontrivial example, from which a number of conclusions are drawn regarding the art and the instruction of programming. © 1971, ACM. All rights reserved.},
	number = {4},
	journal = {Communications of the ACM},
	author = {Wirth, Niklaus},
	year = {1971},
}

@article{alur_theory_1994,
	title = {A theory of timed automata},
	volume = {126},
	issn = {03043975},
	doi = {10.1016/0304-3975(94)90010-8},
	abstract = {We propose timed (finite) automata to model the behavior of real-time systems over time. Our definition provides a simple, and yet powerful, way to annotate state-transition graphs with timing constraints using finitely many real-valued clocks. A timed automaton accepts timed words-infinite sequences in which a real-valued time of occurrence is associated with each symbol. We study timed automata from the perspective of formal language theory: we consider closure properties, decision problems, and subclasses. We consider both nondeterministic and deterministic transition structures, and both Büchi and Muller acceptance conditions. We show that nondeterministic timed automata are closed under union and intersection, but not under complementation, whereas deterministic timed Muller automata are closed under all Boolean operations. The main construction of the paper is an (PSPACE) algorithm for checking the emptiness of the language of a (nondeterministic) timed automaton. We also prove that the universality problem and the language inclusion problem are solvable only for the deterministic automata: both problems are undecidable (Π11-hard) in the nondeterministic case and PSPACE-complete in the deterministic case. Finally, we discuss the application of this theory to automatic verification of real-time requirements of finite-state systems. © 1994.},
	number = {2},
	journal = {Theoretical Computer Science},
	author = {Alur, Rajeev and Dill, David L.},
	year = {1994},
}

@inproceedings{Wimmer2020Reachability,
	title = {Verified certification of reachability checking for timed automata},
	volume = {12078 LNCS},
	doi = {10.1007/978-3-030-45190-5_24},
	abstract = {Prior research has shown how to construct a mechanically verified model checker for timed automata, a popular formalism for modeling real-time systems. In this paper, we shift the focus from verified model checking to certifying unreachability. This allows us to benefit from better approximation operations for symbolic states, and reduces execution time by exploring fewer states and by exploiting parallelism. Moreover, this gives us the ability to audit results of unverified model checkers that implement a range of further optimizations, including certificate compression. The resulting tool is evaluated on a set of standard benchmarks to demonstrate its practicality, using a new unverified model checker implementation in Standard ML to construct the certificates.},
	booktitle = {Lecture {Notes} in {Computer} {Science} (including subseries {Lecture} {Notes} in {Artificial} {Intelligence} and {Lecture} {Notes} in {Bioinformatics})},
	author = {Wimmer, Simon and Mutius, Joshua von},
	year = {2020},
	note = {ISSN: 16113349},
}

@inproceedings{haftmann_data_2013,
	title = {Data refinement in {Isabelle}/{HOL}},
	volume = {7998 LNCS},
	doi = {10.1007/978-3-642-39634-2_10},
	abstract = {The paper shows how the code generator of Isabelle/HOL supports data refinement, i.e., providing efficient code for operations on abstract types, e.g., sets or numbers. This allows all tools that employ code generation, e.g., Quickcheck or proof by evaluation, to compute with these abstract types. At the core is an extension of the code generator to deal with data type invariants. In order to automate the process of setting up specific data refinements, two packages for transferring definitions and theorems between types are exploited. © 2013 Springer-Verlag.},
	booktitle = {Lecture {Notes} in {Computer} {Science} (including subseries {Lecture} {Notes} in {Artificial} {Intelligence} and {Lecture} {Notes} in {Bioinformatics})},
	author = {Haftmann, Florian and Krauss, Alexander and Kunčar, Ondřej and Nipkow, Tobias},
	year = {2013},
	note = {ISSN: 03029743},
}

@inproceedings{wimmer_munta_2019,
	title = {Munta: {A} {Verified} {Model} {Checker} for {Timed} {Automata}},
	volume = {11750 LNCS},
	doi = {10.1007/978-3-030-29662-9_14},
	abstract = {Munta is a mechanically verified model checker for timed automata, a popular formalism for modeling real-time systems. Our goal is two-fold: first, we want to provide a reference implementation that is fast enough to test other model checkers against it on reasonably sized benchmarks; second, the tool should be practical enough so that it can easily be used for experimentation. Munta can be compiled to Standard ML or OCaml and additionally features a web-based GUI. Its modeling language has a simple semantics but provides the most commonly used timed automata modeling features.},
	booktitle = {Lecture {Notes} in {Computer} {Science} (including subseries {Lecture} {Notes} in {Artificial} {Intelligence} and {Lecture} {Notes} in {Bioinformatics})},
	author = {Wimmer, Simon},
	year = {2019},
	note = {ISSN: 16113349},
}

@article{larsen_uppaal_1997,
	title = {Uppaal in a nutshell},
	volume = {1},
	issn = {14332779},
	doi = {10.1007/s100090050010},
	abstract = {This paper presents the overal structure, the design criteria, and the main features of the tool box Uppaal. It gives a detailed user guide which describes how to use the various tools of Uppaal version 2.02 to construct abstract models of a real-time system, to simulate its dynamical behavior, to specify and verify its safety and bounded liveness properties in terms of its model. In addition, the paper also provides a short review on case-studies where Uppaal is applied, as well as references to its theoretical foundation. © 1997 Springer-Verlag.},
	number = {1-2},
	journal = {International Journal on Software Tools for Technology Transfer},
	author = {Larsen, Kim G. and Pettersson, Paul and Yi, Wang},
	year = {1997},
}

@inproceedings{bengtsson_uppaal-tool_1996,
	title = {{UPPAAL}-a tool suite for automatic verification of real-time systems},
	volume = {1066},
	doi = {10.1007/BFb0020949},
	abstract = {UPPAAL is a tool suite for automatic verification of safety and bounded liveness properties of real-time systems modeled as networks of timed automata. It includes: a graphical interface that supports graphical and textual representations of networks of timed automata, and automatic transformation from graphical representations to textual format, a compiler that transforms a certain class of linear hybrid systems to networks of timed automata, and a model-checker which is implemented based on constraint-solving techniques. UPPAAL also supports diagnostic model-checking providing diagnostic information in case verification of a particular real-time systems fails. The current version of UPPAAL is available on the World Wide Web via the UPPAAL home page http://www.does. uu. se/docs/rtmv/uppaal.},
	booktitle = {Lecture {Notes} in {Computer} {Science} (including subseries {Lecture} {Notes} in {Artificial} {Intelligence} and {Lecture} {Notes} in {Bioinformatics})},
	author = {Bengtsson, Johan and Larsen, Kim and Larsson, Fredrik and Pettersson, Paul and Yi, Wang},
	year = {1996},
	note = {ISSN: 16113349},
}

@book{clarke_handbook_2018,
	title = {Handbook of model checking},
	abstract = {Model checking is a computer-assisted method for the analysis of dynamical systems that can be modeled by state-transition systems. Drawing from research traditions in mathematical logic, programming languages, hardware design, and theoretical computer science, model checking is now widely used for the verification of hardware and software in industry. The editors and authors of this handbook are among the world's leading researchers in this domain, and the 32 contributed chapters present a thorough view of the origin, theory, and application of model checking. In particular, the editors classify the advances in this domain and the chapters of the handbook in terms of two recurrent themes that have driven much of the research agenda: the algorithmic challenge, that is, designing model-checking algorithms that scale to real-life problems; and the modeling challenge, that is, extending the formalism beyond Kripke structures and temporal logic. The book will be valuable for researchers and graduate students engaged with the development of formal methods and verification tools.},
	author = {Clarke, Edmund M. and Henzinger, Thomas A. and Veith, Helmut and Bloem, Roderick},
	year = {2018},
	doi = {10.1007/978-3-319-10575-8},
	note = {Publication Title: Handbook of Model Checking},
}

@article{Bouyer2004Forward,
	title = {Forward analysis of updatable timed automata},
	volume = {24},
	issn = {09259856},
	doi = {10.1023/B:FORM.0000026093.21513.31},
	abstract = {Timed automata are a widely studied model. Its decidability has been proved using the so-called region automaton construction. This construction provides a correct abstraction for the behaviours of timed automata, but it suffers from a state explosion and is thus not used in practice. Instead, algorithms based on the notion of zones are implemented using adapted data structures like DBMs. When we focus on forward analysis algorithms, the exact computation of all the successors of the initial configurations does not always terminate. Thus, some abstractions are often used to ensure termination, among which, a widening operator on zones. In this paper, we study in detail this widening operator and the corresponding forward analysis algorithm. This algorithm is most used and implemented in tools like KRONOS and UPPAAL. One of our main results is that it is hopeless to find a forward analysis algorithm for general timed automata, that uses such a widening operator, and which is correct. This goes really against what one could think. We then study in detail this algorithm in the more general framework of updatable timed automata, a model which has been introduced as a natural syntactic extension of classical timed automata. We describe subclasses of this model for which a correct widening operator can be found.},
	number = {3},
	journal = {Formal Methods in System Design},
	author = {Bouyer, Patricia},
	year = {2004},
}

@inproceedings{Roeger2017,
	title = {Towards certified unsolvability in classical planning},
	volume = {0},
	doi = {10.24963/ijcai.2017/738},
	abstract = {While it is easy to verify that an action sequence is a solution for a classical planning task, there is no such verification capability if a task is reported unsolvable. We are therefore interested in certificates that allow an independent verification of the absence of solutions. We identify promising concepts for certificates that can be generated by a wide range of planning approaches. We present a first proposal of unsolvability certificates and sketch ideas how the underlying concepts can be used as part of a more flexible unsolvability proof system.},
	booktitle = {{IJCAI} {International} {Joint} {Conference} on {Artificial} {Intelligence}},
	author = {Röger, Gabriele},
	year = {2017},
	note = {ISSN: 10450823},
}

@inproceedings{eriksson_proof_2018,
	title = {A proof system for unsolvable planning tasks},
	volume = {2018-June},
	doi = {10.1609/icaps.v28i1.13899},
	abstract = {While traditionally classical planning concentrated on finding plans for solvable tasks, detecting unsolvable instances has recently attracted increasing interest. To preclude wrong results, it is desirable that the planning system provides a certificate of unsolvability that can be independently verified. We propose a rule-based proof system for unsolvability where a proof establishes a knowledge base of verifiable basic statements and applies a set of derivation rules to infer the unsolvability of the task from these statements. We argue that this approach is more flexible than a recent proposal of inductive certificates of unsolvability and show how our proof system can be used for a wide range of planning techniques.},
	booktitle = {Proceedings {International} {Conference} on {Automated} {Planning} and {Scheduling}, {ICAPS}},
	author = {Eriksson, Salomé and Röger, Gabriele and Helmert, Malte},
	year = {2018},
	note = {ISSN: 23340843},
}

@inproceedings{giunchiglia_planning_2000,
	title = {Planning as model checking},
	volume = {1809},
	doi = {10.1007/10720246_1},
	abstract = {The goal of this paper is to provide an introduction, with va-rious elements of novelty, to the Planning as Model Checking paradigm.},
	booktitle = {Lecture {Notes} in {Artificial} {Intelligence} ({Subseries} of {Lecture} {Notes} in {Computer} {Science})},
	author = {Giunchiglia, Fausto and Traverso, Paolo},
	year = {2000},
	note = {ISSN: 03029743},
}

@inproceedings{heinz_temporal_2019,
	title = {Temporal planning as refinement-based model checking},
	doi = {10.1609/icaps.v29i1.3476},
	abstract = {Planning as model checking based on source-to-source compilations has found increasing attention. Previously proposed approaches for temporal and hybrid planning are based on static translations, in the sense that the resulting model checking problems are uniquely defined by the given input planning problems. As a drawback, the translations can become too large to be efficiently solvable. In this paper, we address propositional temporal planning, lifting static translations to a more flexible framework. Our framework is based on a refinement cycle that allows for adaptively computing suitable translations of increasing size. Our experiments on temporal IPC domains show that the resulting translations to timed automata often become succinct, resulting in promising performance when applied with the directed model checker MCTA.},
	booktitle = {Proceedings {International} {Conference} on {Automated} {Planning} and {Scheduling}, {ICAPS}},
	author = {Heinz, Alexander and Wehrle, Martin and Bogomolov, Sergiy and Magazzeni, Daniele and Greitschus, Marius and Podelski, Andreas},
	year = {2019},
	note = {ISSN: 23340843},
}

@article{dierks_solving_2002,
	title = {Solving {Planning} {Problems} {Using} {Real}-{Time} {Model} {Checking} ({Translating} {PDDL3} into {Timed} {Automata})},
	author = {Dierks, Henning and Behrmann, Gerd and Larsen, Kim},
	month = aug,
	year = {2002},
}

@inproceedings{abdulaziz_formally_2023,
	title = {Formally {Verified} {SAT}-{Based} {AI} {Planning}},
	volume = {37},
	doi = {10.1609/aaai.v37i12.26714},
	abstract = {We present an executable formally verified SAT encoding of ground classical AI planning problems. We use the theorem prover Isabelle/HOL to perform the verification. We experimentally test the verified encoding and show that it can be used for reasonably sized standard planning benchmarks. We also use it as a reference to test a state-of-the-art SAT-based planner, showing that it sometimes falsely claims that problems have no solutions of certain lengths.},
	booktitle = {Proceedings of the 37th {AAAI} {Conference} on {Artificial} {Intelligence}, {AAAI} 2023},
	author = {Abdulaziz, Mohammad and Kurz, Friedrich},
	year = {2023},
	note = {ISSN: 2159-5399},
}

@article{bouyer_updatable_2004,
	title = {Updatable timed automata},
	volume = {321},
	issn = {0304-3975},
	doi = {10.1016/J.TCS.2004.04.003},
	abstract = {We investigate extensions of Alur and Dill's timed automata, based on the possibility to update the clocks in a more elaborate way than simply reset them to zero. We call these automata updatable timed automata. They form an undecidable class of models, in the sense that emptiness checking is not decidable. However, using an extension of the region graph construction, we exhibit interesting decidable subclasses. In a surprising way, decidability depends on the nature of the clock constraints which are used, diagonal-free or not, whereas these constraints play identical roles in timed automata. We thus describe in a quite precise way the thin frontier between decidable and undecidable classes of updatable timed automata. We also study the expressive power of updatable timed automata. It turns out that any updatable automaton belonging to some decidable subclass can be effectively transformed into an equivalent timed automaton without updates but with silent transitions. The transformation suffers from an enormous combinatorics blow-up which seems unavoidable. Therefore, updatable timed automata appear to be a concise model for representing and analyzing large classes of timed systems. © 2004 Elsevier B.V. All rights reserved.},
	number = {2-3},
	urldate = {2024-08-29},
	journal = {Theoretical Computer Science},
	author = {Bouyer, Patricia and Dufourd, Catherine and Fleury, Emmanuel and Petit, Antoine},
	month = aug,
	year = {2004},
	note = {Publisher: Elsevier},
	pages = {291--345},
	file = {PDF:/home/david/Zotero/storage/4RZIJ7U4/full-text.pdf:application/pdf},
}

@article{bouyer_conciseness_2005,
	title = {On conciseness of extensions of timed automata},
	volume = {10},
	issn = {1430-189X},
	abstract = {In this paper we study conciseness of various extensions of timed automata, and prove that several features like diagonal constraints or updates lead to exponentially more concise timed models.},
	number = {4},
	journal = {J. Autom. Lang. Comb.},
	author = {Bouyer, Patricia and Chevalier, Fabrice},
	month = apr,
	year = {2005},
	note = {Publisher: Otto-von-Guericke-Universitat
Place: DEU},
	keywords = {conciseness, diagonal constraints, timed automata, updates},
	pages = {393--405},
}

@inproceedings{eriksson_certified_2020,
	title = {Certified unsolvability for {SAT} planning with property directed reachability},
	volume = {30},
	doi = {10.1609/icaps.v30i1.6649},
	abstract = {While classical planning systems can usually detect if a task is unsolvable, only recent research introduced a way to verify such a claim. These methods have already been applied to a variety of explicit and symbolic search algorithms, but so far no planning technique based on SAT has been covered with them. We fill this gap by showing how property directed reachability can produce proofs while only minimally altering the framework by allowing to utilize certificates for unsolvable SAT queries within the proof. We additionally show that a variant of the algorithm that does not use SAT calls can produce proofs that fit into the existing framework without requiring any changes.},
	booktitle = {Proceedings {International} {Conference} on {Automated} {Planning} and {Scheduling}, {ICAPS}},
	author = {Eriksson, Salomé and Helmert, Malte},
	year = {2020},
	note = {ISSN: 23340843},
}

@article{gigante_decidability_2022,
	title = {Decidability and complexity of action-based temporal planning over dense time},
	volume = {307},
	issn = {00043702},
	doi = {10.1016/j.artint.2022.103686},
	abstract = {In this paper, we study the computational complexity of action-based temporal planning interpreted over dense time. When time is assumed to be discrete, the problem is known to be EXPSPACE-complete. However, the official PDDL 2.1 semantics and many implementations interpret time as a dense domain. This work provides several results about the complexity of the problem, focusing on some particularly interesting cases: whether a minimum amount ε of separation between mutually exclusive events is given, in contrast to the separation being simply required to be non-zero, and whether or not actions are allowed to overlap already running instances of themselves. We prove the problem to be PSPACE-complete when self-overlap is forbidden, whereas, when it is allowed, it becomes EXPSPACE-complete with ε-separation and even undecidable with non-zero separation. These results clarify the computational consequences of different choices in the definition at the core of the PDDL 2.1 semantics, which have been vague until now.1},
	journal = {Artificial Intelligence},
	author = {Gigante, Nicola and Micheli, Andrea and Montanari, Angelo and Scala, Enrico},
	year = {2022},
}

@article{ballarin_locales_2004,
	title = {Locales and locale expressions in {Isabelle}/{Isar}},
	volume = {3085},
	issn = {16113349},
	doi = {10.1007/978-3-540-24849-1_3},
	abstract = {Locales provide a module system for the Isabelle proof assistant. Recently, locales have been ported to the new Isar format for structured proofs. At the same time, they have been extended by locale expressions, a language for composing locale specifications, and by structures, which provide syntax for algebraic structures. The present paper presents both and is suitable as a tutorial to locales in Isar, because it covers both basics and recent extensions, and contains many examples. © Springer-Verlag 2004.},
	journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
	author = {Ballarin, Clemens},
	year = {2004},
}

@inproceedings{bogomolov_planning_2014,
	title = {Planning as model checking in hybrid domains},
	volume = {3},
	doi = {10.1609/aaai.v28i1.9037},
	abstract = {Planning in hybrid domains is an important and challenging task, and various planning algorithms have been proposed in the last years. From an abstract point of view, hybrid planning domains are based on hybrid automata, which have been studied intensively in the model checking community. In particular, powerful model checking algorithms and tools have emerged for this formalism. However, despite the quest for more scalable planning approaches, model checking algorithms have not been applied to planning in hybrid domains so far. In this paper, we make a first step in bridging the gap between these two worlds. We provide a formal translation scheme from PDDL+ to the standard formalism of hybrid automata, as a solid basis for using hybrid system modelchecking tools for dealing with hybrid planning domains. As a case study, we use the SpaceEx model checker, showing how we can address PDDL+ domains that are out of the scope of state-of-the-art planners.},
	booktitle = {Proceedings of the {National} {Conference} on {Artificial} {Intelligence}},
	author = {Bogomolov, Sergiy and Magazzeni, Daniele and Podelski, Andreas and Wehrle, Martin},
	year = {2014},
	note = {ISSN: 2159-5399},
}

@techreport{mukherjee_reachability_2021,
	address = {Kelambakkam, India},
	title = {Reachability in {Timed} {Automata} with {Diagonal} {Constraints} and {Updates}},
	abstract = {Introduced by Alur and Dill, Timed Automata have been a popular tool for mod elling real-time systems. Several syntactic extensions and restrictions of Timed
Automata have been studied and various problems have been considered over these
classes of automata. This thesis considers the classic reachability problem in Timed
Automata, when the guards of the automata are allowed to contain diagonal con straints, that are expressions comparing the difference between two clocks with a
non-negative integer, and also in the more general class called Updatable Timed
Automata – introduced by Bouyer, Dufourd, Fleury and Petit – that allow transi tions to set the values of clocks to arbitrary non-negative integers, or to the value
of a clock, or even to the sum of the value of a clock and some integer. In contrast,
Timed Automata only allow transitions to (re-)set values of clocks to 0. Diagonal
constraints in Timed Automata provide exponential succinctness, whereas, updates
increase the expressive power.
The aim of this thesis is to improve upon the existing algorithms for checking
reachability in these two classes of automata. The restricted class of diagonal-free
Timed Automata enjoys an efficient reachability algorithm, which is implemented
in several tools, such as UPPAAL, KRONOS, and the more recent TChecker. This
thesis aims to adapt this efficient algorithm to handle the larger classes as well.
In order to adapt the algorithm, two goals need to be achieved: (i) a suitable
simulation relation needs to be constructed, and (ii) an algorithm needs to be
devised for checking this relation between two zones.
This thesis discusses a new relation (vG), parameterized by a set G of atomic
constraints over clocks. Not all choices for the parameter makes the relation a
simulation relation. A fixpoint computation for constructing this parameter is pro posed that ensures the relation becomes a simulation relation for Updatable Timed
Automata and therefore for Timed Automata in particular, as well.
This thesis also describes an algorithm for checking vG between two zones, when
G is allowed to contain diagonals. In the diagonal-free case, this relation can be
checked with the same complexity as that of the popular LU simulation relation.
In the presence of diagonals, checking if this relation does not hold turns out to
be NP-complete. A prototype implementation of this algorithm has been done
inside TChecker. Some preliminary experiments performed using this prototype
are reported in the thesis and these show gains over existing methods for handling
diagonal constraints and updates.},
	urldate = {2024-11-27},
	institution = {Chennai Mathematical Institute},
	author = {Mukherjee, Sayan},
	month = nov,
	year = {2021},
	note = {arXiv: 1806.11007},
	keywords = {India, Kelambakkam, Plot H1, SIPCOT IT Park, Siruseri, Tamil Nadu 603103},
	file = {PDF:/home/david/Zotero/storage/BNQ3V6LQ/m-api-54a64ce6-60cc-7749-649f-d70ee5d1dfa1.pdf:application/pdf},
}

@article{paulson_natural_1986,
	title = {Natural deduction as higher-order resolution},
	volume = {3},
	issn = {07431066},
	doi = {10.1016/0743-1066(86)90015-4},
	abstract = {An interactive theorem prover, Isabelle, is under development. In lcf, each inference rule is represented by one function for forwards proof and another (a tactic) for backwards proof. In Isabelle, each inference rule is represented by a Horn clause. Resolution gives both forwards and backwards proof, supporting a large class of logics. Isabelle has been used to prove theorems in Martin-Löf's constructive type theory. Quantifiers pose several difficulties: substitution, bound variables, Skolemization. Isabelle's representation of logical syntax is the typed λ-calculus, requiring higher-order unification. It may have potential for logic programming. Depth-first subgoaling along inference rules constitutes a higher-order PROLOG. © 1986.},
	number = {3},
	journal = {The Journal of Logic Programming},
	author = {Paulson, Lawrence C.},
	year = {1986},
}

@inproceedings{panjkovic_deciding_2022,
	title = {Deciding {Unsolvability} in {Temporal} {Planning} under {Action} {Non}-{Self}-{Overlapping}},
	volume = {36},
	doi = {10.1609/aaai.v36i9.21225},
	abstract = {The field of Temporal Planning (TP) is receiving increasing interest for its many real-world applications. Most of the literature focuses on the TP problem of finding a plan, with algorithms that are not guaranteed to terminate when the problem admits no solution. In this paper, we present sound and complete decision procedures that address the dual problem of proving that no plan exists, which has important applications in oversubscription, model validation and optimization. We focus on the expressive and practically relevant semantics of action non-self-overlapping, recently proved to be PSPACE-complete. For this subclass, we propose two approaches: a reduction of the planning problem to modelchecking of Timed Transition Systems, and a heuristic-search algorithm where temporal constraints are represented by Difference Bound Matrices. We implemented the approaches, and carried out an experimental evaluation against other stateof- the-art TP tools. On benchmarks that admit no plans, both approaches dramatically outperform the other planners, while the heuristic-search algorithm remains competitive on solvable benchmarks.},
	booktitle = {Proceedings of the 36th {AAAI} {Conference} on {Artificial} {Intelligence}, {AAAI} 2022},
	author = {Panjkovic, Stefan and Micheli, Andrea and Cimatti, Alessandro},
	year = {2022},
	note = {ISSN: 2159-5399},
}

@inproceedings{schaffeler_formally_2023,
	title = {Formally {Verified} {Solution} {Methods} for {Markov} {Decision} {Processes}},
	volume = {37},
	doi = {10.1609/aaai.v37i12.26759},
	abstract = {We formally verify executable algorithms for solving Markov decision processes (MDPs) in the interactive theorem prover Isabelle/HOL. We build on existing formalizations of probability theory to analyze the expected total reward criterion on finite and infinite-horizon problems. Our developments formalize the Bellman equation and give conditions under which optimal policies exist. Based on this analysis, we verify dynamic programming algorithms to solve tabular MDPs. We evaluate the formally verified implementations experimentally on standard problems, compare them with state-of-the-art systems, and show that they are practical.},
	booktitle = {Proceedings of the 37th {AAAI} {Conference} on {Artificial} {Intelligence}, {AAAI} 2023},
	author = {Schäffeler, Maximilian and Abdulaziz, Mohammad},
	year = {2023},
	note = {ISSN: 2159-5399},
}

@inproceedings{behrmann_uppaal_2002,
	title = {{UPPAAL} implementation secrets},
	volume = {2469},
	doi = {10.1007/3-540-45739-9_1},
	abstract = {In this paper we present the continuous and on-going development of datastructures and algorithms underlying the verification engine of the tool Uppaal. In particular, we review the datastructures of Difference Bounded Matrices, Minimal Constraint Representation and Clock Difference Diagrams used in symbolic state-space representation and -analysis for real-time systems. In addition we report on distributed versions of the tool, and outline the design and experimental results for new internal datastructures to be used in the next generation of Uppaal. Finally, we mention work on complementing methods involving acceleration, abstraction and compositionality.},
	booktitle = {Lecture {Notes} in {Computer} {Science} (including subseries {Lecture} {Notes} in {Artificial} {Intelligence} and {Lecture} {Notes} in {Bioinformatics})},
	author = {Behrmann, Gerd and Bengtsson, Johan and David, Alexandre and Larsen, Kim G. and Pettersson, Paul and Yi, Wang},
	year = {2002},
	note = {ISSN: 16113349},
}

@misc{wimmer_timed_2016,
	title = {Timed {Automata} ({AFP})},
	abstract = {Timed automata are a widely used formalism for modeling real-time systems, which is employed in a class of successful model checkers such as UPPAAL [LPY97], HyTech [HHWt97] or Kronos [Yov97]. This work formalizes the theory for the subclass of diagonal-free timed automata, which is sufficient to model many interesting problems. We first define the basic concepts and semantics of diagonal-free timed automata. Based on this, we prove two types of decidability results for the language emptiness problem. The first is the classic result of Alur and Dill [AD90, AD94], which uses a finite partitioning of the state space into so-called `regions`. Our second result focuses on an approach based on `Difference Bound Matrices (DBMs)`, which is practically used by model checkers. We prove the correctness of the basic forward analysis operations on DBMs. One of these operations is the Floyd-Warshall algorithm for the all-pairs shortest paths problem. To obtain a finite search space, a widening operation has to be used for this kind of analysis. We use Patricia Bouyer's [Bou04] approach to prove that this widening operation is correct in the sense that DBM-based forward analysis in combination with the widening operation also decides language emptiness. The interesting property of this proof is that the first decidability result is reused to obtain the second one.},
	publisher = {Archive of Formal Proofs},
	author = {Wimmer, Simon},
	year = {2016},
}

@article{paulson_foundation_1989,
	title = {The foundation of a generic theorem prover},
	volume = {5},
	issn = {01687433},
	doi = {10.1007/BF00248324},
	abstract = {Isabelle [28, 30] is an interactive theorem prover that supports a variety of logics. It represents rules as propositions (not as functions) and builds proofs by combining rules. These operations constitute a meta-logic (or 'logical framework') in which the object-logics are formalized. Isabelle is now based on higher-order logic-a precise and well-understood foundation. Examples illustrate the use of this meta-logic to formalize logics and proofs. Axioms for first-order logic are shown to be sound and complete. Backwards proof is formalized by meta-reasoning about object-level entailment. Higher-order logic has several practical advantages over other meta-logics. Many proof techniques are known, such as Huet's higher-order unification procedure. © 1989 Kluwer Academic Publishers.},
	number = {3},
	journal = {Journal of Automated Reasoning},
	author = {Paulson, Lawrence C.},
	year = {1989},
}

@incollection{paulson_isabelle_1990,
	title = {Isabelle: {The} {Next} 700 {Theorem} {Provers}},
	abstract = {Isabelle is a generic theorem prover, designed for interactive reasoning in a variety of formal theories. At present it provides useful proof procedures for Constructive Type Theory, various first-order logics, Zermelo-Fraenkel set theory, and higher-order logic. This survey of Isabelle serves as an introduction to the literature. It explains why generic theorem proving is beneficial. It gives a thorough history of Isabelle, beginning with its origins in the LCF system. It presents an account of how logics are represented, illustrated using classical logic. The approach is compared with the Edinburgh Logical Framework. Several of the Isabelle object-logics are presented.},
	booktitle = {Logic and {Computer} {Science}},
	author = {Paulson, L C},
	year = {1990},
}

@book{wenzel_isabelleisar_2001,
	title = {The {Isabelle}/{Isar} {Reference} {Manual}},
	publisher = {TU München},
	author = {Wenzel, Markarius},
	year = {2001},
}

@article{hoffmann_distance_nodate,
	title = {``{Distance}''? {Who} {Cares}? {Tailoring} {Merge}-and-{Shrink} {Heuristics} to {Detect} {Unsolvability}},
	abstract = {Research on heuristic functions is all about estimating the length (or cost) of solution paths. But what if there is no such path? Many known heuristics have the ability to detect (some) unsolvable states, but that ability has always been treated as a by-product. No attempt has been made to design heuristics speciﬁcally for that purpose, where there is no need to preserve distances. As a case study towards leveraging that advantage, we investigate merge-and-shrink abstractions in classical planning. We identify safe abstraction steps (no information loss regarding solvability) that would not be safe for traditional heuristics. We design practical algorithm conﬁgurations, and run extensive experiments showing that our heuristics outperform the state of the art for proving planning tasks unsolvable.},
	language = {en},
	author = {Hoffmann, Joerg and Kissmann, Peter and Torralba, Alvaro},
	file = {PDF:/home/david/Zotero/storage/WIDG7HRF/Hoffmann et al. - ``Distance'' Who Cares Tailoring Merge-and-Shrink Heuristics to Detect Unsolvability.pdf:application/pdf},
}

@article{panjkovic_deciding_2022-1,
	title = {Deciding {Unsolvability} in {Temporal} {Planning} under {Action} {Non}-{Self}-{Overlapping}},
	volume = {36},
	issn = {2374-3468, 2159-5399},
	url = {https://ojs.aaai.org/index.php/AAAI/article/view/21225},
	doi = {10.1609/aaai.v36i9.21225},
	abstract = {The ﬁeld of Temporal Planning (TP) is receiving increasing interest for its many real-world applications. Most of the literature focuses on the TP problem of ﬁnding a plan, with algorithms that are not guaranteed to terminate when the problem admits no solution. In this paper, we present sound and complete decision procedures that address the dual problem of proving that no plan exists, which has important applications in oversubscription, model validation and optimization. We focus on the expressive and practically relevant semantics of action non-self-overlapping, recently proved to be PSPACE-complete. For this subclass, we propose two approaches: a reduction of the planning problem to modelchecking of Timed Transition Systems, and a heuristic-search algorithm where temporal constraints are represented by Difference Bound Matrices. We implemented the approaches, and carried out an experimental evaluation against other stateof-the-art TP tools. On benchmarks that admit no plans, both approaches dramatically outperform the other planners, while the heuristic-search algorithm remains competitive on solvable benchmarks.},
	language = {en},
	number = {9},
	urldate = {2025-07-10},
	journal = {AAAI},
	author = {Panjkovic, Stefan and Micheli, Andrea and Cimatti, Alessandro},
	month = jun,
	year = {2022},
	note = {Publisher: Association for the Advancement of Artificial Intelligence (AAAI)},
	pages = {9886--9893},
	file = {PDF:/home/david/Zotero/storage/5C7IZEZF/Panjkovic et al. - 2022 - Deciding Unsolvability in Temporal Planning under Action Non-Self-Overlapping.pdf:application/pdf},
}

@incollection{marzal_e_detection_2008,
	title = {Detection of unsolvable temporal planning problems through the use of landmarks},
	url = {https://www.medra.org/servlet/aliasResolver?alias=iospressISSNISBN&issn=0922-6389&volume=178&spage=919},
	abstract = {Deadline constraints have been recently introduced in PDDL3.0. The results obtained in the constraints domains in the last Planning Competition show that planners are not yet fully competitive. When dealing with deadline constraints the number of feasible solutions for a problem is reduced and thus it is specially relevant the ability to detect unsolvability. In this paper we present a new approach, based on the use of temporal landmarks, for the detection of unsolvable temporal planning problems.},
	language = {en},
	urldate = {2025-07-10},
	booktitle = {Frontiers in {Artificial} {Intelligence} and {Applications}},
	publisher = {IOS Press},
	collaborator = {{Marzal E.} and {Sebastia L.} and {Onaindia E.}},
	year = {2008},
	doi = {10.3233/978-1-58603-891-5-919},
	note = {ISSN: 0922-6389},
	file = {PDF:/home/david/Zotero/storage/MIP9U2CK/2008 - Detection of unsolvable temporal planning problems through the use of landmarks.pdf:application/pdf},
}

@article{leroy_formal_2009,
	title = {Formal verification of a realistic compiler},
	volume = {52},
	copyright = {https://www.acm.org/publications/policies/copyright\_policy\#Background},
	issn = {0001-0782, 1557-7317},
	url = {https://dl.acm.org/doi/10.1145/1538788.1538814},
	doi = {10.1145/1538788.1538814},
	abstract = {This paper reports on the development and formal verification (proof of semantic preservation) of CompCert, a compiler from Clight (a large subset of the C programming language) to PowerPC assembly code, using the Coq proof assistant both for programming the compiler and for proving its correctness. Such a verified compiler is useful in the context of critical software and its formal verification: the verification of the compiler guarantees that the safety properties proved on the source code hold for the executable compiled code as well.},
	language = {en},
	number = {7},
	urldate = {2025-07-11},
	journal = {Commun. ACM},
	author = {Leroy, Xavier},
	month = jul,
	year = {2009},
	note = {Publisher: Association for Computing Machinery (ACM)},
	pages = {107--115},
	file = {PDF:/home/david/Zotero/storage/MAQCFQ9N/Leroy - 2009 - Formal verification of a realistic compiler.pdf:application/pdf},
}

@inproceedings{kumar_cakeml_2014,
	address = {San Diego California USA},
	title = {{CakeML}: a verified implementation of {ML}},
	copyright = {https://www.acm.org/publications/policies/copyright\_policy\#Background},
	shorttitle = {{CakeML}},
	url = {https://dl.acm.org/doi/10.1145/2535838.2535841},
	doi = {10.1145/2535838.2535841},
	abstract = {We have developed and mechanically veriﬁed an ML system called CakeML, which supports a substantial subset of Standard ML. CakeML is implemented as an interactive read-eval-print loop (REPL) in x86-64 machine code. Our correctness theorem ensures that this REPL implementation prints only those results permitted by the semantics of CakeML. Our veriﬁcation effort touches on a breadth of topics including lexing, parsing, type checking, incremental and dynamic compilation, garbage collection, arbitraryprecision arithmetic, and compiler bootstrapping.},
	language = {en},
	urldate = {2025-07-11},
	booktitle = {Proceedings of the 41st {ACM} {SIGPLAN}-{SIGACT} {Symposium} on {Principles} of {Programming} {Languages}},
	publisher = {ACM},
	author = {Kumar, Ramana and Myreen, Magnus O. and Norrish, Michael and Owens, Scott},
	month = jan,
	year = {2014},
	pages = {179--191},
	file = {PDF:/home/david/Zotero/storage/FRGH8EN8/Kumar et al. - 2014 - CakeML a verified implementation of ML.pdf:application/pdf},
}

@article{mcconnell_certifying_2011,
	title = {Certifying algorithms},
	volume = {5},
	copyright = {https://www.elsevier.com/tdm/userlicense/1.0/},
	issn = {1574-0137},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S1574013710000560},
	doi = {10.1016/j.cosrev.2010.09.009},
	abstract = {A certifying algorithm is an algorithm that produces, with each output, a certiﬁcate or witness (easy-to-verify proof) that the particular output has not been compromised by a bug. A user of a certifying algorithm inputs x, receives the output y and the certiﬁcate w, and then checks, either manually or by use of a program, that w proves that y is a correct output for input x. In this way, he/she can be sure of the correctness of the output without having to trust the algorithm.},
	language = {en},
	number = {2},
	urldate = {2025-07-11},
	journal = {Computer Science Review},
	author = {McConnell, R.M. and Mehlhorn, K. and Näher, S. and Schweitzer, P.},
	month = may,
	year = {2011},
	note = {Publisher: Elsevier BV},
	pages = {119--161},
	file = {PDF:/home/david/Zotero/storage/KPGAFAVI/McConnell et al. - 2011 - Certifying algorithms.pdf:application/pdf},
}

@inproceedings{li_planning_2012,
	title = {Planning as {Model} {Checking} {Tasks}},
	url = {https://ieeexplore.ieee.org/document/6479815},
	doi = {10.1109/SEW.2012.25},
	abstract = {Model checking provides a way to automatically verify hardware and software systems, whereas the goal of planning is to produce a sequence of actions that leads from the initial state to the desired goal states. Recent research indicates that there is a strong connection between model checking and planning problem solving. In this paper, we investigate the feasibility of using different model checking tools and techniques for solving classic planning problems. To achieve this, we carried out a number of experiments on different planning domains in order to compare the performance and capabilities of various tools. Our experimental results indicate that the performance of some model checkers is comparable to that of state-of-the- art planners for certain categories of problems. In particular, a new planning module with specifically designed searching algorithm is implemented on top of the established model checking framework, Process Analysis Toolkit (PAT), to serve as a planning solution provider for upper layer applications. A case study on a public transportation management system has been developed to demonstrate the idea of using the PAT model checker as a planning service.},
	urldate = {2025-07-11},
	booktitle = {2012 35th {Annual} {IEEE} {Software} {Engineering} {Workshop}},
	author = {Li, Yi and Sun, Jing and Dong, Jin Song and Liu, Yang and Sun, Jun},
	month = oct,
	year = {2012},
	note = {ISSN: 1550-6215},
	keywords = {Automate Planning, Bridges, Computational modeling, Educational institutions, Games, Model checking, Model Checking, Planning, Safety},
	pages = {177--186},
	file = {Snapshot:/home/david/Zotero/storage/ZZVUAK5Y/6479815.html:text/html},
}

@inproceedings{stohr_automated_2012,
	series = {{CEUR} {Workshop} {Proceedings}},
	title = {Automated {Composition} of {Timed} {Services} by {Planning} as {Model} {Checking}},
	volume = {847},
	url = {https://ceur-ws.org/Vol-847/paper5.pdf},
	urldate = {2025-07-11},
	booktitle = {Proceedings of the 4{\textbackslash}({\textasciicircum}{\textbackslash}mboxth{\textbackslash}) {Central}-{European} {Workshop} on {Services} and their {Composition}, {ZEUS}-2012, {Bamberg}, {Germany}, {February} 23-24, 2012},
	publisher = {CEUR-WS.org},
	author = {Stöhr, Daniel and Glesner, Sabine},
	editor = {Schönberger, Andreas and Kopp, Oliver and Lohmann, Niels},
	year = {2012},
	pages = {34--41},
}

@article{muise_unplannability_2015,
	title = {Unplannability {IPC} {Track}},
	abstract = {The majority of research in the ﬁeld of automated planning focuses on the synthesis of plans for problems that are solvable. We propose an IPC track to focus on the important and understudied area of unplannibility: proving that a planning problem is unsolvable. We will focus on classical planning problems, as methods for determining whether or not unplannability can have wider applications for classical planning problems (e.g., recognizing and avoiding deadends in the state space) as well as solving planning problems with uncertainty (e.g., identifying when a deterministic approximation of the problem is unsolvable). The unplannability track follows similar contests in other ﬁelds; for example, the UNSAT track for the ﬁeld of Boolean Satisﬁability. In a similar vein, we hope that the introduction of an unplannability track will foster new innovation for techniques dedicated to identifying planning problems that cannot be solved.},
	language = {en},
	author = {Muise, Christian and Lipovetzky, Nir},
	year = {2015},
	file = {PDF:/home/david/Zotero/storage/S5SAYNRC/Muise and Lipovetzky - Unplannability IPC Track.pdf:application/pdf},
}

@inproceedings{hoffmann_distance_2014,
	address = {NLD},
	series = {{ECAI}'14},
	title = {"{Distance}"? {Who} {Cares}? tailoring merge-and-shrink heuristics to detect unsolvability},
	isbn = {978-1-61499-418-3},
	shorttitle = {"{Distance}"?},
	abstract = {Research on heuristic functions is all about estimating the length (or cost) of solution paths. But what if there is no such path? Many known heuristics have the ability to detect (some) unsolvable states, but that ability has always been treated as a by-product. No attempt has been made to design heuristics specifically for that purpose, where there is no need to preserve distances. As a case study towards leveraging that advantage, we investigate merge-and-shrink abstractions in classical planning. We identify safe abstraction steps (no information loss regarding solvability) that would not be safe for traditional heuristics. We design practical algorithm configurations, and run extensive experiments showing that our heuristics outperform the state of the art for proving planning tasks unsolvable.},
	urldate = {2025-07-10},
	booktitle = {Proceedings of the {Twenty}-first {European} {Conference} on {Artificial} {Intelligence}},
	publisher = {IOS Press},
	author = {Hoffmann, Jörg and Kissmann, Peter and Torralba, Alvaro},
	month = aug,
	year = {2014},
	pages = {441--446},
}

@article{suda_property_2014,
	title = {Property {Directed} {Reachability} for {Automated} {Planning}},
	volume = {50},
	copyright = {Copyright (c)},
	issn = {1076-9757},
	url = {https://www.jair.org/index.php/jair/article/view/10886},
	doi = {10.1613/jair.4231},
	abstract = {Property Directed Reachability (PDR) is a very promising recent method for deciding reachability in symbolically represented transition systems. While originally conceived as a model checking algorithm for hardware circuits, it has already been successfully applied in several other areas. This paper is the first investigation of PDR from the perspective of automated planning.
 
Similarly to the planning as satisfiability paradigm, PDR draws its strength from internally employing an efficient SAT-solver. We show that most standard encoding schemes of planning into SAT can be directly used to turn PDR into a planning algorithm. As a non-obvious alternative, we propose to replace the SAT-solver inside PDR by a planning-specific procedure implementing the same interface. This SAT-solver free variant is not only more efficient, but offers additional insights and opportunities for further improvements. An experimental comparison to the state of the art planners finds it highly competitive, solving most problems on several domains.},
	language = {en},
	urldate = {2025-07-11},
	journal = {Journal of Artificial Intelligence Research},
	author = {Suda, M.},
	month = jun,
	year = {2014},
	pages = {265--319},
	file = {Full Text PDF:/home/david/Zotero/storage/CFKEPHT5/Suda - 2014 - Property Directed Reachability for Automated Planning.pdf:application/pdf},
}

@article{seipp_fast_2016,
	title = {Fast {Downward} {Aidos}},
	language = {en},
	author = {Seipp, Jendrik and Sievers, Silvan and Hutter, Frank},
	year = {2016},
	file = {PDF:/home/david/Zotero/storage/KWI9BUR4/Seipp et al. - Fast Downward Aidos.pdf:application/pdf},
}

@inproceedings{cimatti_extending_2019,
	address = {Cham},
	title = {Extending {nuXmv} with {Timed} {Transition} {Systems} and {Timed} {Temporal} {Properties}},
	isbn = {978-3-030-25540-4},
	doi = {10.1007/978-3-030-25540-4_21},
	abstract = {nuXmv is a well-known symbolic model checker, which implements various state-of-the-art algorithms for the analysis of finite- and infinite-state transition systems and temporal logics. In this paper, we present a new version that supports timed systems and logics over continuous super-dense semantics. The system specification was extended with clocks to constrain the timed evolution. The support for temporal properties has been expanded to include \$\${\textbackslash}textsc \{MTL\}\_\{0,{\textbackslash}infty \}\$\$formulas with parametric intervals. The analysis is performed via a reduction to verification problems in the discrete-time case. The internal representation of traces has been extended to go beyond the lasso-shaped form, to take into account the possible divergence of clocks. We evaluated the new features by comparing nuXmv with other verification tools for timed automata and \$\${\textbackslash}textsc \{MTL\}\_\{0,{\textbackslash}infty \}\$\$, considering different benchmarks from the literature. The results show that nuXmv is competitive with and in many cases performs better than state-of-the-art tools, especially on validity problems for \$\${\textbackslash}textsc \{MTL\}\_\{0,{\textbackslash}infty \}\$\$.},
	language = {en},
	booktitle = {Computer {Aided} {Verification}},
	publisher = {Springer International Publishing},
	author = {Cimatti, Alessandro and Griggio, Alberto and Magnago, Enrico and Roveri, Marco and Tonetta, Stefano},
	editor = {Dillig, Isil and Tasiran, Serdar},
	year = {2019},
	pages = {376--386},
	file = {Full Text PDF:/home/david/Zotero/storage/773CVFJK/Cimatti et al. - 2019 - Extending nuXmv with Timed Transition Systems and Timed Temporal Properties.pdf:application/pdf},
}
