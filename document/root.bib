@article{Paulson1986,
   abstract = {An interactive theorem prover, Isabelle, is under development. In lcf, each inference rule is represented by one function for forwards proof and another (a tactic) for backwards proof. In Isabelle, each inference rule is represented by a Horn clause. Resolution gives both forwards and backwards proof, supporting a large class of logics. Isabelle has been used to prove theorems in Martin-Löf's constructive type theory. Quantifiers pose several difficulties: substitution, bound variables, Skolemization. Isabelle's representation of logical syntax is the typed λ-calculus, requiring higher-order unification. It may have potential for logic programming. Depth-first subgoaling along inference rules constitutes a higher-order PROLOG. © 1986.},
   author = {Lawrence C. Paulson},
   doi = {10.1016/0743-1066(86)90015-4},
   issn = {07431066},
   issue = {3},
   journal = {The Journal of Logic Programming},
   title = {Natural deduction as higher-order resolution},
   volume = {3},
   year = {1986},
}
@misc{Mukherjee2021,
   abstract = {Introduced by Alur and Dill, Timed Automata have been a popular tool for modelling real-time systems. Several syntactic extensions and restrictions of Timed
Automata have been studied and various problems have been considered over these
classes of automata. This thesis considers the classic reachability problem in Timed
Automata, when the guards of the automata are allowed to contain diagonal constraints, that are expressions comparing the difference between two clocks with a
non-negative integer, and also in the more general class called Updatable Timed
Automata – introduced by Bouyer, Dufourd, Fleury and Petit – that allow transitions to set the values of clocks to arbitrary non-negative integers, or to the value
of a clock, or even to the sum of the value of a clock and some integer. In contrast,
Timed Automata only allow transitions to (re-)set values of clocks to 0. Diagonal
constraints in Timed Automata provide exponential succinctness, whereas, updates
increase the expressive power.
The aim of this thesis is to improve upon the existing algorithms for checking
reachability in these two classes of automata. The restricted class of diagonal-free
Timed Automata enjoys an efficient reachability algorithm, which is implemented
in several tools, such as UPPAAL, KRONOS, and the more recent TChecker. This
thesis aims to adapt this efficient algorithm to handle the larger classes as well.
In order to adapt the algorithm, two goals need to be achieved: (i) a suitable
simulation relation needs to be constructed, and (ii) an algorithm needs to be
devised for checking this relation between two zones.
This thesis discusses a new relation (vG), parameterized by a set G of atomic
constraints over clocks. Not all choices for the parameter makes the relation a
simulation relation. A fixpoint computation for constructing this parameter is proposed that ensures the relation becomes a simulation relation for Updatable Timed
Automata and therefore for Timed Automata in particular, as well.
This thesis also describes an algorithm for checking vG between two zones, when
G is allowed to contain diagonals. In the diagonal-free case, this relation can be
checked with the same complexity as that of the popular LU simulation relation.
In the presence of diagonals, checking if this relation does not hold turns out to
be NP-complete. A prototype implementation of this algorithm has been done
inside TChecker. Some preliminary experiments performed using this prototype
are reported in the thesis and these show gains over existing methods for handling
diagonal constraints and updates.},
   author = {Sayan Mukherjee},
   city = {Kelambakkam, India},
   institution = {Chennai Mathematical Institute},
   keywords = {India,Kelambakkam,Plot H1,SIPCOT IT Park,Siruseri,Tamil Nadu 603103},
   month = {11},
   title = {Reachability in Timed Automata with Diagonal Constraints and Updates},
   url = {https://mukherjee-sayan.github.io/files/sayan-thesis.pdf},
   year = {2021},
}
@inproceedings{Bogomolov2014,
   abstract = {Planning in hybrid domains is an important and challenging task, and various planning algorithms have been proposed in the last years. From an abstract point of view, hybrid planning domains are based on hybrid automata, which have been studied intensively in the model checking community. In particular, powerful model checking algorithms and tools have emerged for this formalism. However, despite the quest for more scalable planning approaches, model checking algorithms have not been applied to planning in hybrid domains so far. In this paper, we make a first step in bridging the gap between these two worlds. We provide a formal translation scheme from PDDL+ to the standard formalism of hybrid automata, as a solid basis for using hybrid system modelchecking tools for dealing with hybrid planning domains. As a case study, we use the SpaceEx model checker, showing how we can address PDDL+ domains that are out of the scope of state-of-the-art planners.},
   author = {Sergiy Bogomolov and Daniele Magazzeni and Andreas Podelski and Martin Wehrle},
   doi = {10.1609/aaai.v28i1.9037},
   issn = {2159-5399},
   booktitle = {Proceedings of the National Conference on Artificial Intelligence},
   title = {Planning as model checking in hybrid domains},
   volume = {3},
   year = {2014},
}
@article{Ballarin2004,
   abstract = {Locales provide a module system for the Isabelle proof assistant. Recently, locales have been ported to the new Isar format for structured proofs. At the same time, they have been extended by locale expressions, a language for composing locale specifications, and by structures, which provide syntax for algebraic structures. The present paper presents both and is suitable as a tutorial to locales in Isar, because it covers both basics and recent extensions, and contains many examples. © Springer-Verlag 2004.},
   author = {Clemens Ballarin},
   doi = {10.1007/978-3-540-24849-1_3},
   issn = {16113349},
   journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
   title = {Locales and locale expressions in Isabelle/Isar},
   volume = {3085},
   year = {2004},
}
@inproceedings{Gastin2018,
   abstract = {We consider the reachability problem for timed automata having diagonal constraints (like x − y < 5) as guards in transitions. The best algorithms for timed automata proceed by enumerating reachable sets of its configurations, stored in a data structure called “zones”. Simulation relations between zones are essential to ensure termination and e ciency. The algorithm employs a simulation test Z Z which ascertains that zone Z does not reach more states than zone Z, and hence further enumeration from Z is not necessary. No e ective simulations are known for timed automata containing diagonal constraints as guards. We propose a simulation relation dLU for timed automata with diagonal constraints. On the negative side, we show that deciding Z dLU Z is NP-complete. On the positive side, we identify a witness for Z dLU Z and propose an algorithm to decide the existence of such a witness using an SMT solver. The shape of the witness reveals that the simulation test is likely to be e cient in practice.},
   author = {Paul Gastin and Sayan Mukherjee and B. Srivathsan},
   doi = {10.4230/LIPIcs.CONCUR.2018.28},
   issn = {18688969},
   booktitle = {Leibniz International Proceedings in Informatics, LIPIcs},
   title = {Reachability in timed automata with diagonal constraints},
   volume = {118},
   year = {2018},
}
@article{Gigante2022,
   abstract = {In this paper, we study the computational complexity of action-based temporal planning interpreted over dense time. When time is assumed to be discrete, the problem is known to be EXPSPACE-complete. However, the official PDDL 2.1 semantics and many implementations interpret time as a dense domain. This work provides several results about the complexity of the problem, focusing on some particularly interesting cases: whether a minimum amount ε of separation between mutually exclusive events is given, in contrast to the separation being simply required to be non-zero, and whether or not actions are allowed to overlap already running instances of themselves. We prove the problem to be PSPACE-complete when self-overlap is forbidden, whereas, when it is allowed, it becomes EXPSPACE-complete with ε-separation and even undecidable with non-zero separation. These results clarify the computational consequences of different choices in the definition at the core of the PDDL 2.1 semantics, which have been vague until now.1},
   author = {Nicola Gigante and Andrea Micheli and Angelo Montanari and Enrico Scala},
   doi = {10.1016/j.artint.2022.103686},
   issn = {00043702},
   journal = {Artificial Intelligence},
   title = {Decidability and complexity of action-based temporal planning over dense time},
   volume = {307},
   year = {2022},
}
@article{CertificationMonads,
   author = {Christian Sternagel and René Thiemann},
   issn = {2150-914x},
   journal = {Archive of Formal Proofs},
   month = {10},
   note = {Formal proof development},
   title = {Certification Monads},
   url = {https://isa-afp.org/entries/Certification_Monads.html},
   year = {2014},
}
@misc{DeadEndPatterns,
   abstract = {This paper describes the three Fast Downward Aidos portfolios we submitted to the Unsolvability International Planning Competition 2016. All three Aidos variants are implemented in the Fast Downward planning system (Helmert 2006). We use a pool of techniques as a basis for our portfolios , including various techniques already implemented Fast Downward, as well as three newly developed techniques to prove unsolvability. We used automatic algorithm configuration to find a good Fast Downward configuration for each of a set of test domains and used the resulting data to select the components, their order and their time slices for our three portfolios. For Aidos 1 and 2 we made this selection manually, resulting in two portfolios comprised mostly of the three new techniques. Aidos 1 distributes the 30 minutes based on our experiments, while Aidos 2 distributes the time uniformly. Aidos 3 contains unmodified configurations from the tuning process with time slices automatically optimized for the number of solved instances per time. It is based both on the new and existing Fast Downward components. The remainder of this planner abstract is organized as follows. First, we describe the three newly developed techniques. Second, we list the previously existing components of Fast Downward that we have used for configuration. Third, we describe the benchmarks used for training and test sets. Fourth, we describe the algorithm configuration process in more detail. Finally, we briefly describe the resulting portfolios. A dead-end pattern database (PDB) stores a set of partial states that are reachable in some abstraction, and for which no plan exists in the abstraction. Every state s encountered during the search can be checked against the dead-end PDB: if s is consistent with any of the stored partial states, then s can be pruned. Since we also submitted a stand-alone planner using only a dead-end PDB to the IPC, we refer to its planner abstract (Pommerening and Seipp 2016) for details on this technique. Dead-end Potentials Dead-end potentials can prove that there is no plan for a state s by finding an invariant that must be satisfied by all states reachable from s but that is unsatisfied in every goal state. The invariants we consider are based on potentials, i.e., numerical values assigned to each state. If potentials exist such that (1) no operator application decreases a state's potential, and (2) the potential of s is higher than the potential of all goal states, then there cannot be a plan for s. In order to describe the form of potentials used in our implementation , we first introduce more terminology. A feature is a conjunction of facts. We say that feature F is true in state s if all facts of F are true in s. We define a numerical weight for each feature. The potential of a state s is defined as the sum of all weights for the features that are true in s. If the planning task is in transition normal form (Pom-merening and Helmert 2015), the conditions (1) and (2) can be expressed as linear constraints over the feature weights. We can use an LP solver to check if there is a solution for these constraints. A solution of the LP forms a certificate for the unsolvability of s. Dead-end potentials can show unsolvability using any set of features. The default feature set we use in most configurations contains all features of up to two facts. We note that the dual of the resulting LP produces an operator counting heuristic (Pommerening et al. 2014). In fact, this is the implementation strategy we used for this method. We use dead-end potentials to prune dead ends in every encountered state. Since only the bounds of the LP differ between states, the LP can be reused by adapting the bounds instead of having to be recreated for every state.},
   author = {Jendrik Seipp and Florian Pommerening and Silvan Sievers and Martin Wehrle and Chris Fawcett and Yusra Alkhazraji},
   title = {Fast Downward Aidos Dead-End Pattern Database},
   year = {2016},
}
@inproceedings{SymPAUnsat,
   author = {Álvaro Torralba},
   title = {SymPA : Symbolic Perimeter Abstractions for Proving Unsolvability},
   url = {https://api.semanticscholar.org/CorpusID:51735243},
   year = {2016},
}
@inproceedings{UnsolvableLocalConsistency,
   abstract = {There has been a tremendous advance in domain-independent planning over the past decades, and planners have become increasingly efficient at finding plans. However, this has not been paired by any corresponding improvement in detecting unsolvable instances. Such instances are obviously important but largely neglected in planning. In other areas, such as constraint solving and model checking, much effort has been spent on devising methods for detecting unsolvability. We introduce a method for detecting unsolvable planning instances that is loosely based on consistency checking in constraint programming. Our method balances completeness against efficiency through a parameter k: the algorithm identifies more unsolvable instances but takes more time for increasing values of k. We present empirical data for our algorithm and some standard planners on a number of unsolvable instances, demonstrating that our method can be very efficient where the planners fail to detect unsolvability within reasonable resource bounds. We observe that planners based on the h m heuristic or pattern databases are better than other planners for detecting unsolvability. This is not a coincidence since there are similarities (but also significant differences) between our algorithm and these two heuristic methods. Copyright © 2013, Association for the Advancement of Artificial Intelligence (www.aaai.org). All rights reserved.},
   author = {Christer Bäckström and Peter Jonsson and Simon Stahlberg},
   doi = {10.1609/socs.v4i1.18294},
   issn = {2832-9171},
   booktitle = {Proceedings of the 6th Annual Symposium on Combinatorial Search, SoCS 2013},
   title = {Fast detection of unsolvable planning instances using local consistency},
   year = {2013},
}
@inproceedings{MSUnsat,
   author = {Álvaro Torralba and Jörg Hoffmann and Peter Kissmann},
   title = {MS-Unsat and SimulationDominance : Merge-and-Shrink and Dominance Pruning for Proving Unsolvability},
   url = {https://api.semanticscholar.org/CorpusID:51806788},
   year = {2016},
}
@inproceedings{Brandao2022,
   abstract = {Temporal planning is a hard problem that requires good heuristic and memoization strategies to solve efficiently. Merge-and-shrink abstractions have been shown to serve as effective heuristics for classical planning, but they have not yet been applied to temporal planning. Currently, it is still unclear how to implement merge-and-shrink in the temporal domain and how effective the method is in this setting. In this paper we propose a method to compute merge-and-shrink abstractions for temporal planning, applicable to both partial- and total-order temporal planners. The method relies on precomputing heuristics as formulas of temporal variables that are evaluated at search time, and it allows to use standard shrinking strategies and label reduction. Compared to state-of-the-art Relaxed Planning Graph heuristics, we show that the method leads to improvements in coverage, computation time, and number of explored nodes to solve optimal problems, as well as leading to improvements in unsolvability-proving of problems with deadlines.},
   author = {Martim Brandao and Amanda Coles and Andrew Coles and Jörg Hoffmann},
   doi = {10.1609/icaps.v32i1.19781},
   issn = {23340843},
   booktitle = {Proceedings International Conference on Automated Planning and Scheduling, ICAPS},
   title = {Merge and Shrink Abstractions for Temporal Planning},
   volume = {32},
   year = {2022},
}
@article{Blum1995,
   abstract = {A program correctness checker is an algorithm for checking the output of a computation. That is, given a program and an instance on which the program is run, the checker certifies whether the output of the program on that instance is correct. This paper defines the concept of a program checker. It designs program checkers for a few specific and carefully chosen problems in the class FP of functions computable in polynomial time. Problems in FP for which checkers are presented in this paper include Sorting, Matrix Rank and GCD. It also applies methods of modern cryptography, especially the idea of a probabilistic interactive proof, to the design of program checkers for group theoretic computations. Two structural theorems are proven here. One is a characterization of problems that can be checked. The other theorem establishes equivalence classes of problems such that whenever one problem in a class is checkable, all problems in the class are checkable. © 1995, ACM. All rights reserved.},
   author = {Manuel Blum and Sampath Kannan},
   doi = {10.1145/200836.200880},
   issn = {1557735X},
   issue = {1},
   journal = {Journal of the ACM (JACM)},
   title = {Designing Programs that Check Their Work},
   volume = {42},
   year = {1995},
}
@article{McConnell2011,
   abstract = {A certifying algorithm is an algorithm that produces, with each output, a certificate or witness (easy-to-verify proof) that the particular output has not been compromised by a bug. A user of a certifying algorithm inputs x, receives the output y and the certificate w, and then checks, either manually or by use of a program, that w proves that y is a correct output for input x. In this way, he/she can be sure of the correctness of the output without having to trust the algorithm.We put forward the thesis that certifying algorithms are much superior to non-certifying algorithms, and that for complex algorithmic tasks, only certifying algorithms are satisfactory. Acceptance of this thesis would lead to a change of how algorithms are taught and how algorithms are researched. The widespread use of certifying algorithms would greatly enhance the reliability of algorithmic software.We survey the state of the art in certifying algorithms and add to it. In particular, we start a theory of certifying algorithms and prove that the concept is universal. © 2010 Elsevier Inc.},
   author = {R. M. McConnell and K. Mehlhorn and S. Näher and P. Schweitzer},
   doi = {10.1016/j.cosrev.2010.09.009},
   issn = {15740137},
   issue = {2},
   journal = {Computer Science Review},
   title = {Certifying algorithms},
   volume = {5},
   year = {2011},
}
@inproceedings{Sreedharan2019,
   abstract = {Explainable planning is widely accepted as a prerequisite for autonomous agents to successfully work with humans. While there has been a lot of research on generating explanations of solutions to planning problems, explaining the absence of solutions remains a largely open and under-studied problem, even though such situations can be the hardest to understand or debug. In this paper, we show that hierarchical abstractions can be used to efficiently generate reasons for unsolvability of planning problems. In contrast to related work on computing certificates of unsolvability, we show that our methods can generate compact, human-understandable reasons for unsolvability. Empirical analysis and user studies show the validity of our methods as well as their computational efficacy on a number of benchmark planning domains.},
   author = {Sarath Sreedharan and Siddharth Srivastava and David Smith and Subbarao Kambhampati},
   doi = {10.24963/ijcai.2019/197},
   issn = {10450823},
   booktitle = {IJCAI International Joint Conference on Artificial Intelligence},
   title = {Why can't you do that hal? Explaining unsolvability of planning tasks},
   volume = {2019-August},
   year = {2019},
}
@article{Donati2011,
   abstract = {This paper describes the algorithms used in a planning and scheduling software tool developed for the European Space Agency in the framework of the Mars Express mission. The planning and scheduling algorithm computes a feasible schedule for the transmission of telecommands (TCs) from the ground segment to the space segment, complying with a number of technical constraints. Owing to the distance between Mars and Earth, it is important that the robustness of the schedule is taken into account because repair operations may be very time consuming or even impossible. For this reason, besides the maximization of the number of TCs transmitted from Earth to Mars, the scheduler is also designed to maximize the number of full confirmations and secondary time windows, which are two special characteristics of the Mars Express schedule explicitly designed for the sake of robustness. Besides the maximization of robustness, the scheduling algorithm that can run with different settings can be used to optimize some secondary figures of merit, such as the average saturation of the memory devices of the space segment and the usage of the time windows available for communication. Computational results on real instances are presented. © 2011 IEEE.},
   author = {Alessandro Donati and Nicola Policella and Erhard Rabenau and Giovanni Righini and Emanuele Tresoldi},
   doi = {10.1109/TSMCC.2011.2114880},
   issn = {10946977},
   issue = {6},
   journal = {IEEE Transactions on Systems, Man and Cybernetics Part C: Applications and Reviews},
   title = {An automatic planning and scheduling system for the Mars Express uplink scheduling problem},
   volume = {41},
   year = {2011},
}
@article{Wimmer2016,
   author = {Simon Wimmer},
   issn = {2150-914x},
   journal = {Archive of Formal Proofs},
   month = {3},
   note = {Formal proof development},
   title = {Timed Automata},
   url = {https://isa-afp.org/entries/Timed_Automata.html},
   year = {2016},
}
@inproceedings{Mehlhorn1998,
   author = {Kurt Mehlhorn and Stefan Näher},
   booktitle = {International Symposium on Mathematical Foundations of Computer Science},
   title = {From Algorithms to Working Programs: On the Use of Program Checking in LEDA},
   url = {https://api.semanticscholar.org/CorpusID:342251},
   year = {1998},
}
@article{Sapena2018,
   author = {O Sapena and Eliseo Marzal and E Onaindia},
   journal = {URL https://ipc2018-temporal. bitbucket. io/planner-abstracts/team2. pdf},
   title = {TFLAP: a temporal forward partial-order planner},
   year = {2018},
}
@article{Sapena2024,
   abstract = {Since the release of PDDL 2.1, many planners accepted the challenge of addressing more complicated domains and problems, including both temporal and numeric features for scheduling and resources management. However, very few planners can handle a significant subset of the features that the language allows for modeling. To handle a level of expressiveness sufficient to work with more realistic problems, we have designed NextFLAP (Numeric EXpressions in TFLAP). The planner follows a hybrid approach, which combines a forward partial-order planner with a numeric constraint solver/optimizer. Additionally, we include a new feature, the control parameters, which are relevant for direct modeling numerical quantities and physical properties of objects in the actions, such as ‘partially charging of a battery’ or ‘obtaining a certain amount of resources’. This feature overcomes a limitation of the PDDL language, which is that the parameters of the actions must be objects (finite domain values) and, in no case, numeric variables. In this paper we illustrate the advantages of using these temporal and numeric modeling features and then describe our planning system, NextFLAP, that can handle these domains. We show that NextFLAP is competitive with other state-of-the-art planners and that it generates good-quality plans.},
   author = {Oscar Sapena and Eva Onaindia and Eliseo Marzal},
   doi = {10.1016/j.eswa.2023.122820},
   issn = {09574174},
   journal = {Expert Systems with Applications},
   title = {A hybrid approach for expressive numeric and temporal planning with control parameters},
   volume = {242},
   year = {2024},
}
@article{Lasota2008,
   abstract = {A notion of alternating timed automata is proposed. It is shown that such automata with only one clock have decidable emptiness problem over finite words. This gives a new class of timed languages that is closed under boolean operations and which has an effective presentation. We prove that the complexity of the emptiness problem for alternating timed automata with one clock is nonprimitive recursive. The proof gives also the same lower bound for the universality problem for nondeterministic timed automata with one clock. We investigate extension of the model with epsilon-transitions and prove that emptiness is undecidable. Over infinite words, we show undecidability of the universality problem. © 2008 ACM.},
   author = {Slawomir Lasota and Igor Walukiewicz},
   doi = {10.1145/1342991.1342994},
   issn = {15293785},
   issue = {2},
   journal = {ACM Transactions on Computational Logic},
   title = {Alternating timed automata},
   volume = {9},
   year = {2008},
}
@inproceedings{Jimenez2015,
   abstract = {In this paper we describe two novel algorithms for temporal planning. The first algorithm, TP, is an adaptation of the Tempo algorithm. It compiles each temporal action into two classical actions, corresponding to the start and end of the temporal action, but handles the temporal constraints on actions through a modification of the Fast Downward planning system. The second algorithm. TPSHE, is a pure compilation from temporal to classical planning for the case in which required concurrency only appears in the form of single hard envelopes. We describe novel classes of temporal planning instances for which TPSHE is provably sound and complete. Compiling a temporal instance into a classical one gives a lot of freedom in terms of the planner or heuristic used to solve the instance. In experiments TPSHE significantly outperforms all planners from the temporal track of the International Planning Competition.},
   author = {Sergio Jiménez and Anders Jonsson and Héctor Palacios},
   doi = {10.1609/icaps.v25i1.13731},
   issn = {23340843},
   booktitle = {Proceedings International Conference on Automated Planning and Scheduling, ICAPS},
   title = {Temporal planning with required concurrency using classical planning},
   volume = {2015-January},
   year = {2015},
}
@inproceedings{FurelosBlanco2018,
   abstract = {In this paper we describe STP, a novel algorithm for temporal planning. Similar to several existing temporal planners, STP relies on a transformation from temporal planning to classical planning, and constructs a temporal plan by finding a sequence of classical actions that solve the problem while satisfying a given set of temporal constraints. Our main contribution is that STP can solve temporal planning problems that require simultaneous events, i.e. the temporal actions have to be scheduled in such a way that two or more of their effects take place concurrently. To do so, STP separates each event into three phases: one phase in which temporal actions are scheduled to end, one phase in which simultaneous effects take place, and one phase in which temporal actions are scheduled to start. Experimental results show that STP significantly outperforms state-of-the-art temporal planners in a domain requiring simultaneous events.},
   author = {Daniel Furelos-Blanco and Anders Jonsson and Héctor Palacios and Sergio Jiménez},
   booktitle = {COPLAS 2018 - Proceedings of the 13th Workshop on Constraint Satisfaction Techniques for Planning and Scheduling Problems},
   title = {Forward-search temporal planning with simultaneous events},
   year = {2018},
}
@inproceedings{Rintanen2007,
   abstract = {We consider the problem of temporal planning in which a given goal is reached by taking a number of actions which may temporally overlap and interfere, and the interference may be essential for reaching the goals. We formalize a general temporal planning problem, show that its plan existence problem is EXPSPACE-complete, and give conditions under which it is reducible to classical planning and is therefore only PSPACE-complete. Our results are the first to show that temporal planning can be computationally more complex than classical planning. They also show how and why a very large and important fragment of temporal PDDL is reducible to classical planning. Copyright © 2007, Association for the Advancement of Artificial Intelligence (www.aaai.org). All rights reserved.},
   author = {Jussi Rintanen},
   booktitle = {ICAPS 2007, 17th International Conference on Automated Planning and Scheduling},
   title = {Complexity of concurrent temporal planning},
   year = {2007},
}
@article{isar-ref,
   abstract = {This volume is a self-contained introduction to interactive proof in higher- order logic (HOL), using the proof assistant Isabelle. It is written for potential users rather than for our colleagues in the research world.},
   author = {TNLC Paulson},
   journal = {2006-06-06]. http://isabelle. in. tum. de},
   title = {A Proof Assistant for Higher-Order Logic},
   year = {2011},
}
@inproceedings{Eriksson2020,
   abstract = {While classical planning systems can usually detect if a task is unsolvable, only recent research introduced a way to verify such a claim. These methods have already been applied to a variety of explicit and symbolic search algorithms, but so far no planning technique based on SAT has been covered with them. We fill this gap by showing how property directed reachability can produce proofs while only minimally altering the framework by allowing to utilize certificates for unsolvable SAT queries within the proof. We additionally show that a variant of the algorithm that does not use SAT calls can produce proofs that fit into the existing framework without requiring any changes.},
   author = {Salomé Eriksson and Malte Helmert},
   doi = {10.1609/icaps.v30i1.6649},
   issn = {23340843},
   booktitle = {Proceedings International Conference on Automated Planning and Scheduling, ICAPS},
   title = {Certified unsolvability for SAT planning with property directed reachability},
   volume = {30},
   year = {2020},
}
@article{Koprowski2011,
   abstract = {Parsing is an important problem in computer science and yet surprisingly little attention has been devoted to its formal verification. In this paper, we present TRX: a parser interpreter formally developed in the proof assistant Coq, capable of producing formally correct parsers. We are using parsing expression grammars (PEGs), a formalism essentially representing recursive descent parsing, which we consider an attractive alternative to context-free grammars (CFGs). From this formalization we can extract a parser for an arbitrary PEG grammar with the warranty of total correctness, i.e., the resulting parser is terminating and correct with respect to its grammar and the semantics of PEGs; both properties formally proven in Coq. © A. Koprowski and H. Binsztok.},
   author = {Adam Koprowski and Henri Binsztok},
   doi = {10.2168/LMCS-7(2:18)2011},
   issn = {18605974},
   issue = {2},
   journal = {Logical Methods in Computer Science},
   title = {TRX: A formally verified parser interpreter},
   volume = {7},
   year = {2011},
}
@inproceedings{Rau2024,
   abstract = {An Earley parser is a top-down parsing technique that is capable of parsing arbitrary context-free grammars. We present a functional implementation of an Earley parser verified using the interactive theorem prover Isabelle/HOL. Our formalization builds upon Cliff Jones' extensive, refinement-based paper proof. We implement and prove soundness and completeness of a functional recognizer modeling Jay Earley's original imperative implementation and extend it with the necessary data structures to enable the construction of parse trees following the work of Elizabeth Scott. Building upon this foundation, we develop a functional parser and prove its soundness. We round off the paper by providing an informal argument and empirical data regarding the running time and space complexity of our implementation.},
   author = {Martin Rau and Tobias Nipkow},
   doi = {10.4230/LIPIcs.ITP.2024.31},
   editor = {Yves Bertot and Temur Kutsia and Michael Norrish},
   booktitle = {15th International Conference on Interactive Theorem Proving, ITP 2024},
   keywords = {Earley,Isabelle,Parsers,Verification},
   month = {9},
   note = {Publisher Copyright: © 2024 Martin Rau and Tobias Nipkow.; 15th International Conference on Interactive Theorem Proving, ITP 2024 ; Conference date: 09-09-2024 Through 14-09-2024},
   publisher = {Schloss Dagstuhl- Leibniz-Zentrum fur Informatik GmbH, Dagstuhl Publishing},
   title = {A Verified Earley Parser},
   year = {2024},
}
@article{Berard1998,
   abstract = {Timed automata are among the most widely studied models for real-time systems. Silent transitions, i.e., ε-transitions, have already been proposed in the original paper on timed automata by Alur and Dill [3]. We show that the class TLε of timed languages recognized by automata with ε-transitions, is more robust and more expressive than the corresponding class TL without ε-transitions We then focus on ε-transitions without reset, i.e. ε-transitions which do not reset clocks. We propose an algorithm to construct, given a timed automaton, an equivalent one without such transitions. This algorithm is in two steps, it first suppresses the cycles of ε-transitions without reset and then the remaining ones. Then, we prove that a timed automaton such that no ε-transition which resets clocks lies on any directed cycle, can be effectively transformed into a timed automaton without ε-transitions. Interestingly, this main result holds under the assumption of non-Zenoness and it is false otherwise. To complete the picture, we exhibit a simple timed automaton with an ε-transition, which resets some clock, on a cycle and which is not equivalent to any ε-free timed automaton. To show this, we develop a promising new technique based on the notion of precise action.},
   author = {Béatrice Bérard and Antoine Petit and Volker Diekert and Paul Gastin},
   doi = {10.3233/fi-1998-36233},
   issn = {01692968},
   issue = {2},
   journal = {Fundamenta Informaticae},
   title = {Characterization of the Expressive Power of Silent Transitions in Timed Automata},
   volume = {36},
   year = {1998},
}
@article{Bouyer2005,
   abstract = {In this paper we study conciseness of various extensions of timed automata, and prove that several features like diagonal constraints or updates lead to exponentially more concise timed models.},
   author = {Patricia Bouyer and Fabrice Chevalier},
   city = {DEU},
   issn = {1430-189X},
   issue = {4},
   journal = {J. Autom. Lang. Comb.},
   keywords = {conciseness,diagonal constraints,timed automata,updates},
   month = {4},
   pages = {393-405},
   publisher = {Otto-von-Guericke-Universitat},
   title = {On conciseness of extensions of timed automata},
   volume = {10},
   year = {2005},
}
@inproceedings{Alur1990,
   author = {R Alur and C Courcoubetis and D Dill},
   doi = {10.1109/LICS.1990.113766},
   booktitle = {[1990] Proceedings. Fifth Annual IEEE Symposium on Logic in Computer Science},
   keywords = {Real time systems;Logic;Delay;Tree graphs;Computer bugs;Contracts;Computer science;Timing;Digital systems;Control systems},
   pages = {414-425},
   title = {Model-checking for real-time systems},
   year = {1990},
}
@article{Bengtsson2004,
   abstract = {This chapter is to provide a tutorial and pointers to results and related work on timed automata with a focus on semantical and algorithmic aspects of verification tools. We present the concrete and abstract semantics of timed automata (based on transition rules, regions and zones), decision problems, and algorithms for verification. A detailed description on DBM (Difference Bound Matrices) is included, which is the central data structure behind several verification tools for timed systems. As an example, we give a brief introduction to the tool UPPAAL. © Springer-Verlag Berlin Heidelberg 2004.},
   author = {Johan Bengtsson and Wang Yi},
   doi = {10.1007/978-3-540-27755-2_3},
   issn = {16113349},
   journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
   title = {Timed automata: Semantics, algorithms and tools},
   volume = {3098},
   year = {2004},
}
@inproceedings{Wimmer2018,
   abstract = {We have constructed a mechanically verified prototype implementation of a model checker for timed automata, a popular formalism for modeling real-time systems. Our goal is two-fold: first, we want to provide a reference implementation that is fast enough to check other model checkers against it on reasonably sized benchmarks; second, we strive for maximal feature compatibility with the state-of-the-art tool Uppaal. The starting point of our work is an existing highly abstract formalization of reachability checking of timed automata. We reduce checking of Uppaal-style models to the problem of model checking a single automaton in this abstract formalization, while retaining the ability to perform on the fly model-checking. Using the Isabelle Refinement Framework, the abstract specification of the model checker is refined, via multiple intermediate steps, to an actual imperative implementation in Standard ML. The resulting tool is evaluated on a set of standard benchmarks to demonstrate its practical usability.},
   author = {Simon Wimmer and Peter Lammich},
   doi = {10.1007/978-3-319-89960-2_4},
   issn = {16113349},
   booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
   title = {Verified model checking of timed automata},
   volume = {10805 LNCS},
   year = {2018},
}
@article{Bouyer2004,
   abstract = {We investigate extensions of Alur and Dill's timed automata, based on the possibility to update the clocks in a more elaborate way than simply reset them to zero. We call these automata updatable timed automata. They form an undecidable class of models, in the sense that emptiness checking is not decidable. However, using an extension of the region graph construction, we exhibit interesting decidable subclasses. In a surprising way, decidability depends on the nature of the clock constraints which are used, diagonal-free or not, whereas these constraints play identical roles in timed automata. We thus describe in a quite precise way the thin frontier between decidable and undecidable classes of updatable timed automata. We also study the expressive power of updatable timed automata. It turns out that any updatable automaton belonging to some decidable subclass can be effectively transformed into an equivalent timed automaton without updates but with silent transitions. The transformation suffers from an enormous combinatorics blow-up which seems unavoidable. Therefore, updatable timed automata appear to be a concise model for representing and analyzing large classes of timed systems. © 2004 Elsevier B.V. All rights reserved.},
   author = {Patricia Bouyer and Catherine Dufourd and Emmanuel Fleury and Antoine Petit},
   doi = {10.1016/J.TCS.2004.04.003},
   issn = {0304-3975},
   issue = {2-3},
   journal = {Theoretical Computer Science},
   month = {8},
   pages = {291-345},
   publisher = {Elsevier},
   title = {Updatable timed automata},
   volume = {321},
   year = {2004},
}
@article{Helmert2009,
   abstract = {We introduce an efficient method for translating planning tasks specified in the standard PDDL formalism into a concise grounded representation that uses finite-domain state variables instead of the straight-forward propositional encoding. Translation is performed in four stages. Firstly, we transform the input task into an equivalent normal form expressed in a restricted fragment of PDDL. Secondly, we synthesize invariants of the planning task that identify groups of mutually exclusive propositions which can be represented by a single finite-domain variable. Thirdly, we perform an efficient relaxed reachability analysis using logic programming techniques to obtain a grounded representation of the input. Finally, we combine the results of the third and fourth stage to generate the final grounded finite-domain representation. The presented approach has originally been implemented as part of the Fast Downward planning system for the 4th International Planning Competition (IPC4). Since then, it has been used in a number of other contexts with considerable success, and the use of concise finite-domain representations has become a common feature of state-of-the-art planners. © 2008 Elsevier B.V. All rights reserved.},
   author = {Malte Helmert},
   doi = {10.1016/j.artint.2008.10.013},
   issn = {00043702},
   issue = {5-6},
   journal = {Artificial Intelligence},
   title = {Concise finite-domain representations for PDDL planning tasks},
   volume = {173},
   year = {2009},
}
@inproceedings{Abdulaziz2023,
   abstract = {We present an executable formally verified SAT encoding of ground classical AI planning problems. We use the theorem prover Isabelle/HOL to perform the verification. We experimentally test the verified encoding and show that it can be used for reasonably sized standard planning benchmarks. We also use it as a reference to test a state-of-the-art SAT-based planner, showing that it sometimes falsely claims that problems have no solutions of certain lengths.},
   author = {Mohammad Abdulaziz and Friedrich Kurz},
   doi = {10.1609/aaai.v37i12.26714},
   issn = {2159-5399},
   booktitle = {Proceedings of the 37th AAAI Conference on Artificial Intelligence, AAAI 2023},
   title = {Formally Verified SAT-Based AI Planning},
   volume = {37},
   year = {2023},
}
@inproceedings{Gnad2019,
   abstract = {Current classical planners are very successful in finding (non-optimal) plans, even for large planning instances. To do so, most planners rely on a preprocessing stage that computes a grounded representation of the task. Whenever the grounded task is too big to be generated (i.e., whenever this preprocess fails) the instance cannot even be tackled by the actual planner. To address this issue, we introduce a partial grounding approach that grounds only a projection of the task, when complete grounding is not feasible. We propose a guiding mechanism that, for a given domain, identifies the parts of a task that are relevant to find a plan by using off-the-shelf machine learning methods. Our empirical evaluation attests that the approach is capable of solving planning instances that are too big to be fully grounded.},
   author = {Daniel Gnad and Álvaro Torralba and Martín Domínguez and Carlos Areces and Facundo Bustos},
   doi = {10.1609/aaai.v33i01.33017602},
   issn = {2159-5399},
   booktitle = {33rd AAAI Conference on Artificial Intelligence, AAAI 2019, 31st Innovative Applications of Artificial Intelligence Conference, IAAI 2019 and the 9th AAAI Symposium on Educational Advances in Artificial Intelligence, EAAI 2019},
   title = {Learning how to ground a plan - partial grounding in classical planning},
   year = {2019},
}
@article{Dierks2002,
   author = {Henning Dierks and Gerd Behrmann and Kim Larsen},
   month = {8},
   title = {Solving Planning Problems Using Real-Time Model Checking (Translating PDDL3 into Timed Automata)},
   year = {2002},
}
@inproceedings{Bogomolov2015,
   abstract = {Planning in hybrid domains poses a special challenge due to the involved mixed discrete-continuous dynamics. A recent solving approach for such domains is based on applying model checking techniques on a translation of PDDL+ planning problems to hybrid automata. However, the proposed translation is limited because must behavior is only overapproximated, and hence, processes and events are not reflected exactly. In this paper, we present the theoretical foundation of an exact PDDL+ translation. We propose a schema to convert a hybrid automaton with must transitions into an equivalent hybrid automaton featuring only may transitions.},
   author = {Sergiy Bogomolov and Daniele Magazzeni and Stefano Minopoli and Martin Wehrle},
   doi = {10.1609/icaps.v25i1.13717},
   issn = {23340843},
   booktitle = {Proceedings International Conference on Automated Planning and Scheduling, ICAPS},
   title = {PDDL+ planning with hybrid automata: Foundations of translating must behavior},
   volume = {2015-January},
   year = {2015},
}
@inproceedings{Heinz2019,
   abstract = {Planning as model checking based on source-to-source compilations has found increasing attention. Previously proposed approaches for temporal and hybrid planning are based on static translations, in the sense that the resulting model checking problems are uniquely defined by the given input planning problems. As a drawback, the translations can become too large to be efficiently solvable. In this paper, we address propositional temporal planning, lifting static translations to a more flexible framework. Our framework is based on a refinement cycle that allows for adaptively computing suitable translations of increasing size. Our experiments on temporal IPC domains show that the resulting translations to timed automata often become succinct, resulting in promising performance when applied with the directed model checker MCTA.},
   author = {Alexander Heinz and Martin Wehrle and Sergiy Bogomolov and Daniele Magazzeni and Marius Greitschus and Andreas Podelski},
   doi = {10.1609/icaps.v29i1.3476},
   issn = {23340843},
   booktitle = {Proceedings International Conference on Automated Planning and Scheduling, ICAPS},
   title = {Temporal planning as refinement-based model checking},
   year = {2019},
}
@inproceedings{Giunchiglia2000,
   abstract = {The goal of this paper is to provide an introduction, with va-rious elements of novelty, to the Planning as Model Checking paradigm.},
   author = {Fausto Giunchiglia and Paolo Traverso},
   doi = {10.1007/10720246_1},
   issn = {03029743},
   booktitle = {Lecture Notes in Artificial Intelligence (Subseries of Lecture Notes in Computer Science)},
   title = {Planning as model checking},
   volume = {1809},
   year = {2000},
}
@inproceedings{Lu2021,
   abstract = {There is a wide agreement that model checking and automated planning (planning for short) are closely related fields. Planning is the task of finding a sequence of appropriate moves that achieves a goal. Model checking aims to prove or disprove a system model that satisfies a given property which is often specified by temporal logics. In this paper we investigate the application of advanced planning techniques to model checking. To this end, a system model is expressed by means of a planning model, and temporal logic property can be treated as a special form of planning goal, i.e., Temporally Extended Goal (TEG). Therefore, the model checking task can be reduced into a planning scheme what we call planning with TEG. In order to utilize the state-of-the-art planners, we further propose two novel compilation methods to translate a planning with TEG problem into a classical planning problem and a non-deterministic planning one respectively. The obtained valid plans in planning just correspond to the counterexamples in model checking. We provide detailed evaluations of our approach on a series of benchmarks. The experimental results are encouraging, showing that existing planners can provide significant improvements in the quality of the counterexamples compared with the model checkers.},
   author = {Xu Lu and Cong Tian and Bin Yu and Zhenhua Duan},
   doi = {10.1109/QRS54544.2021.00079},
   issn = {26939177},
   booktitle = {IEEE International Conference on Software Quality, Reliability and Security, QRS},
   title = {Improving Quality of Counterexamples in Model Checking via Automated Planning},
   volume = {2021-December},
   year = {2021},
}
@inproceedings{Klauck2018,
   abstract = {It has previously been observed that the verification of safety properties in deterministic model-checking frameworks can be compiled into classical planning. A similar connection exists between goal probability analysis on either side, yet that connection has not been explored. We fill that gap with a translation from Jani, an input language for quantitative model checkers including the Modest toolset and PRISM, into PPDDL. Our experiments motivate further cross-fertilization between both research areas, specifically the exchange of algorithms. Our study also initiates the creation of new benchmarks for goal probability analysis.},
   author = {Michaela Klauck and Marcel Steinmetz and Jörg Hoffmann and Holger Hermanns},
   doi = {10.1609/icaps.v28i1.13887},
   issn = {23340843},
   booktitle = {Proceedings International Conference on Automated Planning and Scheduling, ICAPS},
   title = {Compiling probabilistic model checking into probabilistic planning},
   volume = {2018-June},
   year = {2018},
}
@inproceedings{Eriksson2018,
   abstract = {While traditionally classical planning concentrated on finding plans for solvable tasks, detecting unsolvable instances has recently attracted increasing interest. To preclude wrong results, it is desirable that the planning system provides a certificate of unsolvability that can be independently verified. We propose a rule-based proof system for unsolvability where a proof establishes a knowledge base of verifiable basic statements and applies a set of derivation rules to infer the unsolvability of the task from these statements. We argue that this approach is more flexible than a recent proposal of inductive certificates of unsolvability and show how our proof system can be used for a wide range of planning techniques.},
   author = {Salomé Eriksson and Gabriele Röger and Malte Helmert},
   doi = {10.1609/icaps.v28i1.13899},
   issn = {23340843},
   booktitle = {Proceedings International Conference on Automated Planning and Scheduling, ICAPS},
   title = {A proof system for unsolvable planning tasks},
   volume = {2018-June},
   year = {2018},
}
@inproceedings{Roeger2017,
   abstract = {While it is easy to verify that an action sequence is a solution for a classical planning task, there is no such verification capability if a task is reported unsolvable. We are therefore interested in certificates that allow an independent verification of the absence of solutions. We identify promising concepts for certificates that can be generated by a wide range of planning approaches. We present a first proposal of unsolvability certificates and sketch ideas how the underlying concepts can be used as part of a more flexible unsolvability proof system.},
   author = {Gabriele Röger},
   doi = {10.24963/ijcai.2017/738},
   issn = {10450823},
   booktitle = {IJCAI International Joint Conference on Artificial Intelligence},
   title = {Towards certified unsolvability in classical planning},
   volume = {0},
   year = {2017},
}
@inproceedings{Wimmer2020Emptiness,
   abstract = {Model checkers for timed automata are widely used to verify safety-critical, real-time systems. State-of-the-art tools achieve scalability by intricate abstractions. We aim at further increasing the trust in their verification results, in particular for checking liveness properties. To this end, we develop an approach for extracting certificates for the emptiness of timed Büchi automata from model checking runs. These certificates can be double checked by a certifier that we formally verify in Isabelle/HOL. We study liveness certificates in an abstract setting and show that our approach is sound and complete. To also demonstrate its feasibility, we extract certificates for several models checked by TChecker and Imitator, and validate them with our verified certifier.},
   author = {Simon Wimmer and Frédéric Herbreteau and Jaco van de Pol},
   doi = {10.1007/978-3-030-57628-8_4},
   issn = {16113349},
   booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
   title = {Certifying Emptiness of Timed Büchi Automata},
   volume = {12288 LNCS},
   year = {2020},
}
@article{Herbreteau2020,
   abstract = {The reachability problem for timed automata asks if a given automaton has a run leading to an accepting state, and the liveness problem asks if the automaton has an infinite run that visits accepting states infinitely often. Both of these problems are known to be Pspace-complete. We show that if P ≠Pspace, the liveness problem is more difficult than the reachability problem; in other words, we exhibit a family of automata for which solving the reachability problem with the standard algorithm is in P but solving the liveness problem is Pspace-hard. This leads us to revisit the algorithmics for the liveness problem. We propose a notion of a witness for the fact that a timed automaton violates a liveness property. We give an algorithm for computing such a witness and compare it to existing solutions.},
   author = {Frédéric Herbreteau and B. Srivathsan and Thanh Tung Tran and Igor Walukiewicz},
   doi = {10.1145/3372310},
   issn = {1557945X},
   issue = {3},
   journal = {ACM Transactions on Computational Logic},
   title = {Why Liveness for Timed Automata Is Hard, and What We Can Do about It},
   volume = {21},
   year = {2020},
}
@inproceedings{Herbreteau2015,
   abstract = {Standard algorithms for reachability analysis of timed automata are sensitive to the order in which the transitions of the automata are taken. To tackle this problem, we propose a ranking system and a waiting strategy. This paper discusses the reason why the search order matters and shows how a ranking system and a waiting strategy can be integrated into the standard reachability algorithm to alleviate and prevent the problem respectively. Experiments show that the combination of the two approaches gives optimal search order on standard benchmarks except for one example. This suggests that it should be used instead of the standard BFS algorithm for reachability analysis of timed automata.},
   author = {Frédéric Herbreteau and Thanh Tung Tran},
   doi = {10.1007/978-3-319-22975-1_9},
   issn = {16113349},
   booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
   title = {Improving search order for reachability testing in timed automata},
   volume = {9268},
   year = {2015},
}
@article{Bouyer2004Forward,
   abstract = {Timed automata are a widely studied model. Its decidability has been proved using the so-called region automaton construction. This construction provides a correct abstraction for the behaviours of timed automata, but it suffers from a state explosion and is thus not used in practice. Instead, algorithms based on the notion of zones are implemented using adapted data structures like DBMs. When we focus on forward analysis algorithms, the exact computation of all the successors of the initial configurations does not always terminate. Thus, some abstractions are often used to ensure termination, among which, a widening operator on zones. In this paper, we study in detail this widening operator and the corresponding forward analysis algorithm. This algorithm is most used and implemented in tools like KRONOS and UPPAAL. One of our main results is that it is hopeless to find a forward analysis algorithm for general timed automata, that uses such a widening operator, and which is correct. This goes really against what one could think. We then study in detail this algorithm in the more general framework of updatable timed automata, a model which has been introduced as a natural syntactic extension of classical timed automata. We describe subclasses of this model for which a correct widening operator can be found.},
   author = {Patricia Bouyer},
   doi = {10.1023/B:FORM.0000026093.21513.31},
   issn = {09259856},
   issue = {3},
   journal = {Formal Methods in System Design},
   title = {Forward analysis of updatable timed automata},
   volume = {24},
   year = {2004},
}
@book{Clarke2018,
   abstract = {Model checking is a computer-assisted method for the analysis of dynamical systems that can be modeled by state-transition systems. Drawing from research traditions in mathematical logic, programming languages, hardware design, and theoretical computer science, model checking is now widely used for the verification of hardware and software in industry. The editors and authors of this handbook are among the world's leading researchers in this domain, and the 32 contributed chapters present a thorough view of the origin, theory, and application of model checking. In particular, the editors classify the advances in this domain and the chapters of the handbook in terms of two recurrent themes that have driven much of the research agenda: the algorithmic challenge, that is, designing model-checking algorithms that scale to real-life problems; and the modeling challenge, that is, extending the formalism beyond Kripke structures and temporal logic. The book will be valuable for researchers and graduate students engaged with the development of formal methods and verification tools.},
   author = {Edmund M. Clarke and Thomas A. Henzinger and Helmut Veith and Roderick Bloem},
   doi = {10.1007/978-3-319-10575-8},
   journal = {Handbook of Model Checking},
   title = {Handbook of model checking},
   year = {2018},
}
@inproceedings{Dill1990,
   author = {David L. Dill},
   doi = {10.1007/3-540-52148-8_17},
   issn = {16113349},
   booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
   title = {Timing assumptions and verification of finite-state concurrent systems},
   volume = {407 LNCS},
   year = {1990},
}
@inbook{Bouyer2003,
   author = {Patricia Bouyer},
   doi = {10.1007/3-540-36494-3_54},
   title = {Untameable Timed Automata!},
   year = {2003},
}
@article{Herbreteau2016,
   abstract = {We study the reachability problem for timed automata. A standard solution to this problem involves computing a search tree whose nodes are abstractions of zones. These abstractions preserve underlying simulation relations on the state space of the automaton. For both effectiveness and efficiency reasons, they are parameterized by the maximal lower and upper bounds (LU-bounds) occurring in the guards of the automaton. One such abstraction is the a≼LU abstraction defined by Behrmann et al. Since this abstraction can potentially yield non-convex sets, it has not been used in implementations. Firstly, we prove that a≼LU abstraction is the coarsest abstraction with respect to LU-bounds that is sound and complete for reachability. Secondly, we provide an efficient technique to use the a≼LU abstraction to solve the reachability problem.},
   author = {Frédéric Herbreteau and B. Srivathsan and Igor Walukiewicz},
   doi = {10.1016/j.ic.2016.07.004},
   issn = {10902651},
   journal = {Information and Computation},
   title = {Better abstractions for timed automata},
   volume = {251},
   year = {2016},
}
@article{Tripakis2005,
   abstract = {This paper presents an on-the-fly and symbolic technique for efficiently checking timed automata emptiness. It is symbolic because it uses the simulation graph (instead of the region graph). It is on-the-fly because the simulation graph is generated during the test for emptiness. We have implemented a verification tool called Profounder based on this technique. To our knowledge, Profounder is the only available tool for checking emptiness of timed Büchi automata. To illustrate the practical interest of our approach, we show the performances of the tool on a non-trivial case study. © 2005 Springer Science+Business Media, Inc.},
   author = {Stavros Tripakis and Sergio Yovine and Ahmed Bouajjani},
   doi = {10.1007/s10703-005-1632-8},
   issn = {09259856},
   issue = {3},
   journal = {Formal Methods in System Design},
   title = {Checking timed büchi automata emptiness efficiently},
   volume = {26},
   year = {2005},
}
@inproceedings{Bouajjani1997,
   abstract = {This paper presents an on-the-fly and symbolic algorithm for checking whether a timed automaton satisfies a formula of a timed temporal logic which is more expressive than TCTL. The algorithm is on-the-fly in the sense that the state-space is generated dynamically and only the minimal amount of information required by the verification procedure is stored in memory. The algorithm is symbolic in the sense that it manipulates sets of states, instead of states, which are represented as boolean combinations of linear inequalities of clocks. We show how a prototype implementation of our algorithm has improved the performances of the tool KRONOS for the verification of the FDDI protocol.},
   author = {A. Bouajjani and S. Tripakis and S. Yovine},
   doi = {10.1109/real.1997.641266},
   booktitle = {Proceedings - Real-Time Systems Symposium},
   title = {On-the-fly symbolic model checking for real-time systems},
   year = {1997},
}
@inproceedings{Bengtsson1996,
   abstract = {UPPAAL is a tool suite for automatic verification of safety and bounded liveness properties of real-time systems modeled as networks of timed automata. It includes: a graphical interface that supports graphical and textual representations of networks of timed automata, and automatic transformation from graphical representations to textual format, a compiler that transforms a certain class of linear hybrid systems to networks of timed automata, and a model-checker which is implemented based on constraint-solving techniques. UPPAAL also supports diagnostic model-checking providing diagnostic information in case verification of a particular real-time systems fails. The current version of UPPAAL is available on the World Wide Web via the UPPAAL home page http://www.does. uu. se/docs/rtmv/uppaal.},
   author = {Johan Bengtsson and Kim Larsen and Fredrik Larsson and Paul Pettersson and Wang Yi},
   doi = {10.1007/BFb0020949},
   issn = {16113349},
   booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
   title = {UPPAAL-a tool suite for automatic verification of real-time systems},
   volume = {1066},
   year = {1996},
}
@misc{Larsen1997,
   abstract = {This paper presents the overal structure, the design criteria, and the main features of the tool box Uppaal. It gives a detailed user guide which describes how to use the various tools of Uppaal version 2.02 to construct abstract models of a real-time system, to simulate its dynamical behavior, to specify and verify its safety and bounded liveness properties in terms of its model. In addition, the paper also provides a short review on case-studies where Uppaal is applied, as well as references to its theoretical foundation. © 1997 Springer-Verlag.},
   author = {Kim G. Larsen and Paul Pettersson and Wang Yi},
   doi = {10.1007/s100090050010},
   issn = {14332779},
   issue = {1-2},
   journal = {International Journal on Software Tools for Technology Transfer},
   title = {Uppaal in a nutshell},
   volume = {1},
   year = {1997},
}
@inproceedings{Wimmer2019,
   abstract = {Munta is a mechanically verified model checker for timed automata, a popular formalism for modeling real-time systems. Our goal is two-fold: first, we want to provide a reference implementation that is fast enough to test other model checkers against it on reasonably sized benchmarks; second, the tool should be practical enough so that it can easily be used for experimentation. Munta can be compiled to Standard ML or OCaml and additionally features a web-based GUI. Its modeling language has a simple semantics but provides the most commonly used timed automata modeling features.},
   author = {Simon Wimmer},
   doi = {10.1007/978-3-030-29662-9_14},
   issn = {16113349},
   booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
   title = {Munta: A Verified Model Checker for Timed Automata},
   volume = {11750 LNCS},
   year = {2019},
}
@inproceedings{Haftmann2013,
   abstract = {The paper shows how the code generator of Isabelle/HOL supports data refinement, i.e., providing efficient code for operations on abstract types, e.g., sets or numbers. This allows all tools that employ code generation, e.g., Quickcheck or proof by evaluation, to compute with these abstract types. At the core is an extension of the code generator to deal with data type invariants. In order to automate the process of setting up specific data refinements, two packages for transferring definitions and theorems between types are exploited. © 2013 Springer-Verlag.},
   author = {Florian Haftmann and Alexander Krauss and Ondřej Kunčar and Tobias Nipkow},
   doi = {10.1007/978-3-642-39634-2_10},
   issn = {03029743},
   booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
   title = {Data refinement in Isabelle/HOL},
   volume = {7998 LNCS},
   year = {2013},
}
@inproceedings{Lammich2010,
   abstract = {The Isabelle Collections Framework (ICF) provides a unified framework for using verified collection data structures in Isabelle/HOL formalizations and generating efficient functional code in ML, Haskell, and OCaml. Thanks to its modularity, it is easily extensible and supports switching to different data structures any time. For good integration with applications, a data refinement approach separates the correctness proofs from implementation details. The generated code based on the ICF lies in better complexity classes than the one that uses Isabelle's default setup (logarithmic vs. linear time). In a case study with tree automata, we demonstrate that the ICF is easy to use and efficient: An ICF based, verified tree automata library outperforms the unverified Timbuk/Taml library by a factor of 14. © 2010 Springer-Verlag.},
   author = {Peter Lammich and Andreas Lochbihler},
   doi = {10.1007/978-3-642-14052-5_24},
   issn = {03029743},
   booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
   title = {The Isabelle collections framework},
   volume = {6172 LNCS},
   year = {2010},
}
@misc{Haftmann2016,
   abstract = {This tutorial introduces the code generator facilities of Isabelle/HOL. They empower the user to turn HOL specifications into corresponding executable programs in the languages SML, OCaml, Haskell and Scala.},
   author = {Florian Haftmann},
   journal = {Code generation from Isabelle/HOL theories},
   title = {Code generation from Isabelle/HOL theories},
   year = {2016},
}
@inproceedings{Kumar2016,
   author = {Ramana Kumar},
   title = {Self-compilation and self-verification},
   url = {https://api.semanticscholar.org/CorpusID:62983827},
   year = {2016},
}
@article{Wildmoser2004,
   abstract = {We formalise a simple assembly language with procedures and a safety policy for arithmetic overflow in Isabelle/HOL. To verify individual programs we use a safety logic. Such a logic can be realised in Isabelle/HOL either as shallow or deep embedding. In a shallow embedding logical formulas are written as HOL predicates, whereas a deep embedding models formulas as a datatype. This paper presents and discusses both variants pointing out their specific strengths and weaknesses. © Springer-Verlag 2004.},
   author = {Martin Wildmoser and Tobias Nipkow},
   doi = {10.1007/978-3-540-30142-4_22},
   issn = {16113349},
   journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
   title = {Certifying Machine Code Safety: Shallow Versus Deep Embedding},
   volume = {3223},
   year = {2004},
}
@article{Bozzelli2020,
   abstract = {Planning is one of the most studied problems in computer science. In this paper, we focus on the timeline-based approach, where the domain is modeled by a set of independent, but interacting, components, each one represented by a number of state variables, whose behavior over time (timelines) is governed by a set of temporal constraints (transition functions and synchronization rules). Whereas the time domain is usually assumed to be discrete, here we address decidability and complexity issues for timeline-based planning (TP) over dense time. We first prove that dense TP is undecidable in the general case; then, we show that decidability can be recovered by restricting to synchronization rules with a suitable future semantics. More “tractable” settings can be obtained by additionally constraining the form of intervals used in rules: EXPSPACE-completeness is obtained by avoiding singular intervals, and PSPACE-completeness by admitting only intervals of the forms [0,a] and [b,+∞[. Finally, NP-completeness can be proved for dense TP with purely existential rules only.},
   author = {Laura Bozzelli and Alberto Molinari and Angelo Montanari and Adriano Peron and Gerhard Woeginger},
   doi = {10.1016/j.tcs.2019.12.030},
   issn = {03043975},
   journal = {Theoretical Computer Science},
   title = {Timeline-based planning over dense temporal domains},
   volume = {813},
   year = {2020},
}
@inproceedings{Boulton1992,
   abstract = {The semantics of hardware description languages can be represented in higher order logic. This provides a formal definition that is suitable for machine processing. Experiments are in progress at Cambridge to see whether this method can be the basis of practical tools based on the HOL theorem-proving assistant. Three languages are being investigated: ELLA, Silage and VHDL. The approaches taken for these languages are compared and current progress on building semantically-based theorem-proving},
   author = {Richard J Boulton and Andrew Gordon and Michael J C Gordon and John Harrison and John Herbert and John van Tassel},
   issn = {1939-0610},
   booktitle = {Proceedings of the IFIP TC10/WG 10.2 International Conference on Theorem Provers in Circuit Design: Theory, Practice and Experience},
   title = {Experience with embedding hardware description languages in HOL},
   year = {1992},
}
@inproceedings{Daws1998,
   abstract = {Practical real-time model checking suffers from the state-explosion problem: the size of the state space grows exponentially with many system parameters: number of clocks, size of constants, number of system components. To cope with state explosion, we propose to use abstractions reducing the state-space while preserving reachability properties. Four exact, plus one safe abstractions are defined. In the main abstraction (simulation) a concrete state is mapped to a symbolic abstract state (a set of concrete states). The other four abstractions are defined on top of the simulation one. They can be computed on-the-fly in a completely orthogonal manner and thus can be combined to yield better reductions. A prototype implementation in the tool Kronos has permitted to verify two benchmark examples with a significant scale-up in size.},
   author = {Conrado Daws and Stavros Tripakis},
   doi = {10.1007/bfb0054180},
   issn = {16113349},
   booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
   title = {Model checking of real-time reachability properties using abstractions},
   volume = {1384},
   year = {1998},
}
@article{Behrmann2003,
   abstract = {By definition Timed Automata have an infinite state-space, thus for verification purposes, an exact finite abstraction is required. We propose a locationbased finite zone abstraction, which computes an abstraction based on the relevant guards for a particular state of the model (as opposed to all guards). We show that the location-based zone abstraction is sound and complete with respect to location reachability; that it generalises active-clock reduction, in the sense that an inactive clock has no relevant guards at all; that it enlarges the class of timed automata, that can be verified. We generalise the new abstraction to the case of networks of timed automata, and experimentally demonstrate a potentially exponential speedup compared to the usual abstraction. © Springer-Verlag Berlin Heidelberg 2003.},
   author = {Gerd Behrmann and Patricia Bouyer and Emmanuel Fleury and Kim G. Larsen},
   doi = {10.1007/3-540-36577-x_18},
   issn = {16113349},
   journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
   title = {Static guard analysis in timed automata verification},
   volume = {2619},
   year = {2003},
}
@article{Behrmann2004,
   abstract = {Timed automata have an infinite semantics. For verification purposes, one usually uses zone based abstractions w.r.t. the maximal constants to which clocks of the timed automaton are compared. We show that by distinguishing maximal lower and upper bounds, significantly coarser abstractions can be obtained. We show soundness and completeness of the new abstractions w.r.t. reachability. We demonstrate how information about lower and upper bounds can be used to optimise the algorithm for bringing a difference bound matrix into normal form. Finally, we experimentally demonstrate that the new techniques dramatically increases the scalability of the real-time model checker UPPAAL. © Springer-Verlag 2004.},
   author = {Gerd Behrmann and Patricia Bouyer and Kim G. Larsen and Radek Pelánek},
   doi = {10.1007/978-3-540-24730-2_25},
   issn = {16113349},
   journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
   title = {Lower and Upper Bounds in Zone Based Abstractions of Timed Automata},
   volume = {2988},
   year = {2004},
}
@inproceedings{Wimmer2020Reachability,
   abstract = {Prior research has shown how to construct a mechanically verified model checker for timed automata, a popular formalism for modeling real-time systems. In this paper, we shift the focus from verified model checking to certifying unreachability. This allows us to benefit from better approximation operations for symbolic states, and reduces execution time by exploring fewer states and by exploiting parallelism. Moreover, this gives us the ability to audit results of unverified model checkers that implement a range of further optimizations, including certificate compression. The resulting tool is evaluated on a set of standard benchmarks to demonstrate its practicality, using a new unverified model checker implementation in Standard ML to construct the certificates.},
   author = {Simon Wimmer and Joshua von Mutius},
   doi = {10.1007/978-3-030-45190-5_24},
   issn = {16113349},
   booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
   title = {Verified certification of reachability checking for timed automata},
   volume = {12078 LNCS},
   year = {2020},
}
@inproceedings{Gigante2020,
   abstract = {This paper studies the computational complexity of temporal planning, as represented by PDDL 2.1, interpreted over dense time. When time is considered discrete, the problem is known to be EXPSPACE-complete. However, the official PDDL 2.1 semantics, and many implementations, interpret time as a dense domain. This work provides several results about the complexity of the problem, studying a few interesting cases: whether a minimum amount ? of separation between mutually exclusive events is given, in contrast to the separation being simply required to be non-zero, and whether or not actions are allowed to overlap already running instances of themselves. We prove the problem to be PSPACE-complete when self-overlap is forbidden, whereas, when allowed, it becomes EXPSPACE-complete with ?-separation and undecidable with non-zero separation. These results clarify the computational consequences of different choices in the definition of the PDDL 2.1 semantics, which were vague until now.},
   author = {Nicola Gigante and Andrea Micheli and Angelo Montanari and Enrico Scala},
   doi = {10.1609/aaai.v34i06.6539},
   issn = {2159-5399},
   booktitle = {AAAI 2020 - 34th AAAI Conference on Artificial Intelligence},
   title = {Decidability and Complexity of Action-Based Temporal Planning over Dense Time},
   year = {2020},
}
@article{Alur1994,
   abstract = {We propose timed (finite) automata to model the behavior of real-time systems over time. Our definition provides a simple, and yet powerful, way to annotate state-transition graphs with timing constraints using finitely many real-valued clocks. A timed automaton accepts timed words-infinite sequences in which a real-valued time of occurrence is associated with each symbol. We study timed automata from the perspective of formal language theory: we consider closure properties, decision problems, and subclasses. We consider both nondeterministic and deterministic transition structures, and both Büchi and Muller acceptance conditions. We show that nondeterministic timed automata are closed under union and intersection, but not under complementation, whereas deterministic timed Muller automata are closed under all Boolean operations. The main construction of the paper is an (PSPACE) algorithm for checking the emptiness of the language of a (nondeterministic) timed automaton. We also prove that the universality problem and the language inclusion problem are solvable only for the deterministic automata: both problems are undecidable (Π11-hard) in the nondeterministic case and PSPACE-complete in the deterministic case. Finally, we discuss the application of this theory to automatic verification of real-time requirements of finite-state systems. © 1994.},
   author = {Rajeev Alur and David L. Dill},
   doi = {10.1016/0304-3975(94)90010-8},
   issn = {03043975},
   issue = {2},
   journal = {Theoretical Computer Science},
   title = {A theory of timed automata},
   volume = {126},
   year = {1994},
}
@article{Wirth1971,
   abstract = {The creative activity of programming--to be distinguished from coding--is usually taught by examples serving to exhibit certain techniques. It is here considered as a sequence of design decisions concerning the decomposition of tasks into subtasks and of data into data structures. The process of successive refinement of specifications is illustrated by a short but nontrivial example, from which a number of conclusions are drawn regarding the art and the instruction of programming. © 1971, ACM. All rights reserved.},
   author = {Niklaus Wirth},
   doi = {10.1145/362575.362577},
   issn = {15577317},
   issue = {4},
   journal = {Communications of the ACM},
   title = {Program Development by Stepwise Refinement},
   volume = {14},
   year = {1971},
}
@inproceedings{Cashmore2015,
   abstract = {The Robot Operating System (ROS) is a set of software libraries and tools used to build robotic systems. ROS is known for a distributed and modular design. Given a model of the environment, task planning is concerned with the assembly of actions into a structure that is predicted to achieve goals. This can be done in a way that minimises costs, such as time or energy. Task planning is vital in directing the actions of a robotic agent in domains where a causal chain could lock the agent into a dead-end state. Moreover, planning can be used in less constrained domains to provide more intelligent behaviour. This paper describes the ROSPlan framework, an architecture for embedding task planning into ROS systems. We provide a description of the architecture and a case study in autonomous robotics. Our case study involves autonomous underwater vehicles in scenarios that demonstrate the flexibility and robustness of our approach.},
   author = {Michael Cashmore and Maria Fox and Derek Long and Daniele Magazzeni and Bram Ridder and Arnau Carrera and Narcís Palomeras and Natàlia Hurtós and Marc Carreras},
   doi = {10.1609/icaps.v25i1.13699},
   isbn = {9781577357315},
   issn = {23340843},
   booktitle = {Proceedings International Conference on Automated Planning and Scheduling, ICAPS},
   pages = {333-341},
   title = {Rosplan: Planning in the robot operating system},
   volume = {2015-Janua},
   year = {2015},
}
@inproceedings{Eyerich2006,
   abstract = {Action formalisms such as GOLOG or FLUX have been developed primarily for representing and reasoning about change in a logical framework. For this reason, expressivity was the main goal in the development of these formalisms. In another line of research, efficiency of planning methods was the topmost goal resulting in the basic STRIPS language, which has only moderate expressivity. The planning language PDDL developed since 1998 is an extension of basic STRIPS with many expressive features. Now the interesting question is how PDDL compares to GOLOG or other action languages from an expressivity point of view. We will show that a GOLOG fragment, which we call Restricted Basic Action Theories, is as expressive as the ADL fragment of PDDL. To prove this equivalence we use the compilation framework. From a practical point of view, this result can be used for employing efficient planners inside a GOLOG interpreter. Copyright © held by author.},
   author = {Patrick Eyerich and Bernhard Nebel and Gerhard Lakemeyer and Jens Claßen},
   doi = {10.1145/1232425.1232440},
   isbn = {1740521307},
   booktitle = {ACM International Conference Proceeding Series},
   pages = {93-104},
   title = {GOLOG and PDDL: What is the relative expressiveness?},
   volume = {213},
   year = {2006},
}
@article{Haftmann2007,
   author = {Florian Haftmann and Tobias Nipkow},
   journal = {Theorem Proving in Higher Order Logics (TPHOLs 2007). Lecture Notes in Computer Science},
   pages = {128-143},
   title = {A code generator framework for Isabelle/HOL},
   volume = {4732},
   year = {2007},
}
@article{Propositional_Proof_Systems,
   author = {Julius Michaelis and Tobias Nipkow},
   issn = {2150-914x},
   journal = {Archive of Formal Proofs},
   month = {6},
   note = {Formal proof development},
   title = {Propositional Proof Systems},
   url = {http://isa-afp.org/entries/Propositional_Proof_Systems.html},
   year = {2017},
}
@article{STRIPS,
   author = {Richard E Fikes and Nils J Nilsson},
   issue = {3-4},
   journal = {Artificial intelligence},
   pages = {189-208},
   publisher = {Elsevier},
   title = {STRIPS: A new approach to the application of theorem proving to problem solving},
   volume = {2},
   year = {1971},
}
@article{Bylander1994,
   author = {T Bylander},
   issue = {1-2},
   journal = {Artificial Intelligence},
   pages = {165-204},
   title = {The Computational Complexity of Propositional \{STRIPS\} Planning},
   volume = {69},
   year = {1994},
}
@inproceedings{BrunnerCAVA,
   author = {Julian Brunner and Peter Lammich},
   institution = {Springer},
   booktitle = {NASA Formal Methods Symposium},
   pages = {307-321},
   title = {Formal Verification of an Executable LTL Model Checker with Partial Order Reduction},
   year = {2016},
}
@book{Paulson1994Isabelle,
   author = {Lawrence C Paulson},
   publisher = {Springer},
   title = {Isabelle: A generic theorem prover},
   volume = {828},
   year = {1994},
}
@inproceedings{Abdulaziz2018,
   abstract = {In this paper we present a formally verified validator for planning problems and their solutions. We formalise the semantics of a fragment of PDDL (V, ¬, →, = in the preconditions, typing and constants) in the Higher-Order Logic theorem prover Isabelle/HOL. We then construct an efficient plan validator and mechanically prove it correct w.r.t. our semantics. We argue that our approach provides a superior compromise in constructing validators where one can have the best of two worlds: (i) clear and concise semantics w.r.t. which the validator is built thus helping to avoid bugs (unlike existing validators, which we show have bugs) and (ii) an optimised implementation whose performance is competitive with mainstream unverified validators.},
   author = {Mohammad Abdulaziz and Peter Lammich},
   doi = {10.1109/ICTAI.2018.00079},
   isbn = {9781538674499},
   issn = {10823409},
   institution = {IEEE},
   booktitle = {Proceedings - International Conference on Tools with Artificial Intelligence, ICTAI},
   keywords = {Formal Verification,Plan Validator},
   pages = {474-479},
   title = {A formally verified validator for classical planning problems and solutions},
   volume = {2018-Novem},
   year = {2018},
}
@article{helmert2014merge,
   author = {Malte Helmert and Patrik Haslum and Jörg Hoffmann and Raz Nissim},
   issue = {3},
   journal = {Journal of the ACM (JACM)},
   pages = {16},
   publisher = {ACM},
   title = {Merge-and-shrink abstraction: A method for generating lower bounds in factored state spaces},
   volume = {61},
   year = {2014},
}
@misc{PDDLref,
   abstract = {This manual describes the syntax of PDDL, the Planning Domain Definition Language, the problem-specification language for the AIPS-98 planning competition. The language has roughly the the expressiveness of Pednault’s ADL [10] for propositions, and roughly the expressiveness of UMCP [6] for actions. Our hope is to encourage empirical evaluation of planner performance, and development of standard sets of problems all in comparable notations.},
   author = {D McDermott and M Ghallab and A Howe and C},
   institution = {CVC TR-98-003/DCS TR-1165, Yale Center for Computational Vision and Control},
   journal = {The AIPS-98 Planning Competition Committee},
   pages = {27},
   title = {PDDL - The Planning Domain Definition Language},
   url = {http://www.citeulike.org/user/kira/article/4097279},
   year = {1998},
}
@inproceedings{Kautz1992,
   author = {H A Kautz and B Selman},
   booktitle = {ECAI},
   pages = {359-363},
   title = {Planning as Satisfiability},
   year = {1992},
}
@inproceedings{Howey2004,
   author = {Richard Howey and Derek Long and Maria Fox},
   booktitle = {Tools with Artificial Intelligence, 2004},
   title = {VAL: Automatic plan validation, continuous effects and mixed initiative planning using PDDL},
   year = {2004},
}
@inproceedings{Lochbihler2013,
   author = {Andreas Lochbihler},
   institution = {Springer},
   booktitle = {International Conference on Interactive Theorem Proving},
   pages = {116-132},
   title = {Light-weight containers for Isabelle: efficient, extensible, nestable},
   year = {2013},
}
@inproceedings{Rintanen2004,
   author = {Jussi Rintanen},
   booktitle = {Proc. 16th European Conf. on Artificial Intelligence},
   pages = {682-687},
   publisher = {IOS Press},
   title = {Evaluation Strategies for Planning as Satisfiability},
   year = {2004},
}
@article{Helmert2006,
   author = {Malte Helmert},
   journal = {Journal of Artificial Intelligence Research},
   pages = {191-246},
   title = {The Fast Downward Planning System},
   volume = {26},
   year = {2006},
}
@article{PDDL21,
   author = {Maria Fox and Derek Long},
   journal = {Journal of artificial intelligence research},
   title = {PDDL2.1: An extension to PDDL for expressing temporal planning domains},
   year = {2003},
}
@article{Eriksson2017,
   author = {Salomé Eriksson and Gabriele Röger and Malte Helmert},
   title = {Unsolvability Certificates for Classical Planning},
   year = {2017},
}
@inproceedings{Abdulaziz2022,
   abstract = {We present a simple and concise semantics for temporal planning. Our semantics are developed and formalised in the logic of the interactive theorem prover Isabelle/HOL. We derive from those semantics a validation algorithm for temporal planning and show, using a formal proof in Isabelle/HOL, that this validation algorithm implements our semantics. We experimentally evaluate our verified validation algorithm and show that it is practical.},
   author = {Mohammad Abdulaziz and Lukas Koller},
   doi = {10.1609/aaai.v36i9.21197},
   isbn = {1577358767},
   issn = {2159-5399},
   booktitle = {Proceedings of the 36th AAAI Conference on Artificial Intelligence, AAAI 2022},
   pages = {9635-9643},
   title = {Formal Semantics and Formally Verified Validation for Temporal Planning},
   volume = {36},
   year = {2022},
}
